[
  {
    "model": "questions.problem",
    "pk": 1,
    "fields": {
      "question": "네트워크에서 여러 장치가 동시에 전송하려 할 때 충돌을 줄이기 위해 사용되는 장치는?",
      "choice1": "스위치",
      "choice2": "라우터",
      "choice3": "리피터",
      "choice4": "허브",
      "answer": 1,
      "explanation": "스위치는 충돌 도메인을 분리하여 데이터 충돌을 줄여준다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 2,
    "fields": {
      "question": "인터넷에서 데이터를 패킷 단위로 전송하는 방식을 무엇이라고 하는가?",
      "choice1": "버스 교환 방식",
      "choice2": "패킷 교환 방식",
      "choice3": "회선 교환 방식",
      "choice4": "프레임 교환 방식",
      "answer": 2,
      "explanation": "인터넷은 패킷 단위로 데이터를 나누어 전송하는 패킷 교환 방식을 사용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 3,
    "fields": {
      "question": "MAC 주소는 어느 계층에서 사용되는 주소인가?",
      "choice1": "네트워크 계층",
      "choice2": "응용 계층",
      "choice3": "데이터링크 계층",
      "choice4": "전송 계층",
      "answer": 3,
      "explanation": "MAC 주소는 데이터링크 계층의 물리적 주소로 사용된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 4,
    "fields": {
      "question": "HTTP는 어떤 형태의 통신 프로토콜인가?",
      "choice1": "물리 계층 프로토콜",
      "choice2": "회선형 프로토콜",
      "choice3": "연결형 프로토콜",
      "choice4": "비연결형 프로토콜",
      "answer": 4,
      "explanation": "HTTP는 요청-응답 시점에만 연결을 유지하는 비연결형 프로토콜이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 5,
    "fields": {
      "question": "브라우저 주소창에 입력한 URL에서 www.example.com",
      "choice1": "포트 번호",
      "choice2": "IP 주소",
      "choice3": "도메인 이름",
      "choice4": "프로토콜 이름",
      "answer": 3,
      "explanation": "www.example.com은",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 6,
    "fields": {
      "question": "한 네트워크 내에서 브로드캐스트 트래픽이 전달되는 범위를 무엇이라고 하는가?",
      "choice1": "브로드캐스트 도메인",
      "choice2": "세션 영역",
      "choice3": "충돌 도메인",
      "choice4": "라우팅 테이블",
      "answer": 1,
      "explanation": "브로드캐스트 도메인의 범위는 라우터를 기준으로 분리된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 7,
    "fields": {
      "question": "네트워크 장치 중 서로 다른 네트워크를 연결하는 역할을 하는 장치는?",
      "choice1": "허브",
      "choice2": "스위치",
      "choice3": "라우터",
      "choice4": "리피터",
      "answer": 3,
      "explanation": "라우터는 네트워크 간 패킷 전달을 담당한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 8,
    "fields": {
      "question": "TCP와 달리 데이터의 신뢰성을 보장하지 않는 전송 계층 프로토콜은?",
      "choice1": "SMTP",
      "choice2": "FTP",
      "choice3": "ICMP",
      "choice4": "UDP",
      "answer": 4,
      "explanation": "UDP는 비연결형이며 신뢰성을 보장하지 않는 프로토콜이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 9,
    "fields": {
      "question": "IPv4 주소의 길이는 몇 비트인가?",
      "choice1": "128비트",
      "choice2": "64비트",
      "choice3": "16비트",
      "choice4": "32비트",
      "answer": 4,
      "explanation": "IPv4는 32비트 주소 체계를 사용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 10,
    "fields": {
      "question": "DHCP가 자동으로 할당하는 정보가 아닌 것은?",
      "choice1": "게이트웨이 주소",
      "choice2": "도메인 이름",
      "choice3": "IP 주소",
      "choice4": "서브넷 마스크",
      "answer": 2,
      "explanation": "DHCP는 도메인 이름 자체를 관리하지 않고 DNS 서버 주소를 제공한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 11,
    "fields": {
      "question": "HTTPS에서 통신을 보호하기 위해 사용하는 기술은?",
      "choice1": "NAT",
      "choice2": "SSL/TLS",
      "choice3": "ARP",
      "choice4": "MAC",
      "answer": 2,
      "explanation": "HTTPS는 SSL/TLS 기반 암호화를 사용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 12,
    "fields": {
      "question": "동일 네트워크 내에서 상대 MAC 주소를 알아내기 위해 사용하는 프로토콜은?",
      "choice1": "NAT",
      "choice2": "RARP",
      "choice3": "ICMP",
      "choice4": "ARP",
      "answer": 4,
      "explanation": "ARP는 IP 주소로 MAC 주소를 조회하는 프로토콜이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 13,
    "fields": {
      "question": "ping 명령어가 내부적으로 사용하는 프로토콜은?",
      "choice1": "FTP",
      "choice2": "TCP",
      "choice3": "UDP",
      "choice4": "ICMP",
      "answer": 4,
      "explanation": "ping은 ICMP Echo 요청/응답 메시지를 이용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 14,
    "fields": {
      "question": "네트워크에서 패킷이 최적 경로로 이동하도록 경로를 선택하는 기능을 무엇이라 하는가?",
      "choice1": "브로드캐스팅",
      "choice2": "라우팅",
      "choice3": "포워딩",
      "choice4": "스위칭",
      "answer": 2,
      "explanation": "라우팅은 목적지까지의 최적 경로를 결정한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 15,
    "fields": {
      "question": "NAT의 주요 목적은 무엇인가?",
      "choice1": "데이터 암호화",
      "choice2": "전송 속도 증가",
      "choice3": "공인 IP 절약",
      "choice4": "회선 안정화",
      "answer": 3,
      "explanation": "NAT는 사설 IP를 공인 IP로 변환해 IPv4 주소 부족을 해결한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 16,
    "fields": {
      "question": "OSI 7계층에서 전기적 신호를 다루는 계층은?",
      "choice1": "네트워크 계층",
      "choice2": "물리 계층",
      "choice3": "세션 계층",
      "choice4": "데이터 링크 계층",
      "answer": 2,
      "explanation": "물리 계층은 케이블, 신호 등 하드웨어적 요소를 다룬다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 17,
    "fields": {
      "question": "Wi-Fi와 같은 무선 LAN 기술에서 사용되는 표준은?",
      "choice1": "IEEE 802.11",
      "choice2": "IEEE 802.3",
      "choice3": "IEEE 802.5",
      "choice4": "IEEE 802.15",
      "answer": 1,
      "explanation": "IEEE 802.11은 무선 LAN 표준이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 18,
    "fields": {
      "question": "브라우저가 웹 서버에 페이지 요청을 보낼 때 사용하는 기본 메서드는?",
      "choice1": "POST",
      "choice2": "PUT",
      "choice3": "DELETE",
      "choice4": "GET",
      "answer": 4,
      "explanation": "GET은 서버에서 자원을 요청하는 기본 메서드이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 19,
    "fields": {
      "question": "서버가 동시에 많은 클라이언트 요청을 처리할 수 있게 만드는 소프트웨어는?",
      "choice1": "웹 서버",
      "choice2": "라우터",
      "choice3": "모뎀",
      "choice4": "스위치",
      "answer": 1,
      "explanation": "웹 서버는 HTTP 요청을 받아 처리하는 역할을 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 20,
    "fields": {
      "question": "IP 패킷의 조각화(Fragmentation)가 일어나는 이유는?",
      "choice1": "대역폭을 늘리기 위해",
      "choice2": "라우팅 테이블 부족 때문",
      "choice3": "MTU 크기 제한 때문",
      "choice4": "암호화를 위해",
      "answer": 3,
      "explanation": "MTU보다 큰 패킷은 조각화되어 전송된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 21,
    "fields": {
      "question": "TCP 3-way handshake에서 첫 번째 메시지는?",
      "choice1": "SYN-ACK",
      "choice2": "FIN",
      "choice3": "ACK",
      "choice4": "SYN",
      "answer": 4,
      "explanation": "연결 시작을 위해 클라이언트는 SYN을 보낸다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 22,
    "fields": {
      "question": "서버가 클라이언트 요청을 받지 못하도록 접속을 차단하는 공격은?",
      "choice1": "XSS",
      "choice2": "SQL Injection",
      "choice3": "DDoS",
      "choice4": "Brute Force",
      "answer": 3,
      "explanation": "DDoS는 과도한 트래픽을 보내 서비스 마비를 유도한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 23,
    "fields": {
      "question": "도메인을 IP 주소로 변환하는 요청을 DNS 서버에게 보낼 때 사용하는 통신 방식은?",
      "choice1": "스트림(Stream)",
      "choice2": "세션(Session)",
      "choice3": "토큰(Token)",
      "choice4": "질의(Query)",
      "answer": 4,
      "explanation": "DNS는 질의-응답 방식으로 동작한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 24,
    "fields": {
      "question": "스위치가 MAC 주소 테이블을 이용해 프레임을 전달하는 방식을 무엇이라 하는가?",
      "choice1": "스위칭",
      "choice2": "캡슐화",
      "choice3": "라우팅",
      "choice4": "브로드캐스팅",
      "answer": 1,
      "explanation": "스위칭은 목적 MAC을 기준으로 프레임을 전달한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 25,
    "fields": {
      "question": "SSL 인증서의 주요 역할은 무엇인가?",
      "choice1": "데이터 압축",
      "choice2": "패킷 분할",
      "choice3": "서버의 신뢰성 검증",
      "choice4": "네트워크 속도 향상",
      "answer": 3,
      "explanation": "인증서는 서버의 신뢰성을 증명하고 암호화에 사용된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 26,
    "fields": {
      "question": "LAN에서 주로 사용되는 케이블 종류는?",
      "choice1": "동축 케이블",
      "choice2": "HDMI 케이블",
      "choice3": "UTP 케이블",
      "choice4": "광케이블",
      "answer": 3,
      "explanation": "대부분의 유선 LAN은 UTP 케이블을 사용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 27,
    "fields": {
      "question": "TCP가 흐름 제어를 위해 사용하는 기법은?",
      "choice1": "ARP 매핑",
      "choice2": "세그멘테이션",
      "choice3": "슬라이딩 윈도우",
      "choice4": "라우팅 테이블",
      "answer": 3,
      "explanation": "슬라이딩 윈도우는 송수신 속도를 조절한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 28,
    "fields": {
      "question": "VPN의 핵심 기능은?",
      "choice1": "암호화된 가상 터널 제공",
      "choice2": "대역폭을 증가",
      "choice3": "IP 주소를 무작위로 생성",
      "choice4": "공유기를 자동 설정",
      "answer": 1,
      "explanation": "VPN은 공용 네트워크에서도 안전한 통신을 제공한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 29,
    "fields": {
      "question": "FTP의 기본 용도는 무엇인가?",
      "choice1": "메일 전송",
      "choice2": "오류 검사",
      "choice3": "파일 전송",
      "choice4": "경로 탐색",
      "answer": 3,
      "explanation": "FTP는 파일 업로드/다운로드 용도이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 30,
    "fields": {
      "question": "POP3는 어떤 용도로 사용되는 프로토콜인가?",
      "choice1": "스트리밍 전달",
      "choice2": "메일 수신",
      "choice3": "웹 페이지 제공",
      "choice4": "메일 발신",
      "answer": 2,
      "explanation": "POP3는 서버에서 메일을 가져오는 프로토콜이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 31,
    "fields": {
      "question": "서브넷팅에서 서브넷 마스크가 길어질수록 네트워크에 미치는 영향은?",
      "choice1": "브로드캐스트 도메인이 커진다",
      "choice2": "라우팅 테이블이 사라진다",
      "choice3": "네트워크 속도가 느려진다",
      "choice4": "호스트 수가 감소한다",
      "answer": 4,
      "explanation": "서브넷 마스크가 길어질수록 사용 가능한 호스트 수는 줄어들고 네트워크는 더 세분화된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 32,
    "fields": {
      "question": "TCP에서 혼잡 제어 기법으로 사용되지 않는 것은?",
      "choice1": "빠른 재전송",
      "choice2": "느린 시작",
      "choice3": "스트리밍 모드",
      "choice4": "혼잡 회피",
      "answer": 3,
      "explanation": "스트리밍 모드는 존재하지 않으며, 나머지는 TCP 혼잡 제어 알고리즘이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 33,
    "fields": {
      "question": "VLAN을 구성하는 주된 목적은 무엇인가?",
      "choice1": "IP 주소를 자동 할당하기 위해",
      "choice2": "논리적으로 네트워크를 분리하기 위해",
      "choice3": "네트워크 속도를 무조건 증가시키기 위해",
      "choice4": "라우터 없이 인터넷에 연결하기 위해",
      "answer": 2,
      "explanation": "VLAN은 물리적 장비를 공유하면서도 논리적으로 네트워크를 분리한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 34,
    "fields": {
      "question": "OSPF의 특징으로 올바른 것은?",
      "choice1": "링크 상태 기반 라우팅 프로토콜이다",
      "choice2": "AS 전체에 단일 경로만 제공한다",
      "choice3": "거리 벡터 방식만 사용한다",
      "choice4": "라우터 간에 경로 정보 교환이 없다",
      "answer": 1,
      "explanation": "OSPF는 링크 상태 라우팅 프로토콜이며, 토폴로지 정보를 기반으로 최적 경로를 계산한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 35,
    "fields": {
      "question": "라우팅 프로토콜에서 Administrative Distance(AD)의 목적은?",
      "choice1": "경로의 신뢰도를 판단하는 기준",
      "choice2": "대역폭을 관리하는 역할",
      "choice3": "암호화 수준을 정의하는 역할",
      "choice4": "패킷 크기를 제한하는 역할",
      "answer": 1,
      "explanation": "AD는 여러 라우팅 정보 중 어떤 경로를 우선 사용할지 결정하는 신뢰도 지표이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 36,
    "fields": {
      "question": "TCP의 포트 번호 범위 중 Well-known Port 범위는?",
      "choice1": "1024~49151",
      "choice2": "49152~65535",
      "choice3": "0~1023",
      "choice4": "10000~20000",
      "answer": 3,
      "explanation": "Well-known Port는 0~1023 범위로 주요 서비스가 예약되어 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 37,
    "fields": {
      "question": "IPv6가 IPv4와 비교해 가지는 장점이 아닌 것은?",
      "choice1": "주소 공간 축소",
      "choice2": "NAT 불필요",
      "choice3": "보안 기능 내장",
      "choice4": "헤더 구조 단순화",
      "answer": 1,
      "explanation": "IPv6는 주소 공간이 확장되며 NAT를 거의 필요로 하지 않는다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 38,
    "fields": {
      "question": "BGP의 주요 역할은 무엇인가?",
      "choice1": "브로드캐스트 관리",
      "choice2": "DNS 주소 변환",
      "choice3": "AS 간 라우팅 정보 교환",
      "choice4": "LAN 내 스위칭",
      "answer": 3,
      "explanation": "BGP는 인터넷 상 서로 다른 AS 간에 라우팅 경로를 교환하는 프로토콜이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 39,
    "fields": {
      "question": "프레임 릴레이나 MPLS에서 사용되는 논리적 연결 방식은?",
      "choice1": "패킷 플러딩",
      "choice2": "브로드캐스트",
      "choice3": "가상 회선",
      "choice4": "일대일 매핑",
      "answer": 3,
      "explanation": "가상 회선 방식은 논리적으로 연결된 경로를 설정하여 전달한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 40,
    "fields": {
      "question": "NAT의 문제점으로 가장 적절한 것은?",
      "choice1": "종단 간 연결성이 떨어질 수 있다",
      "choice2": "라우팅 테이블이 없어도 된다",
      "choice3": "네트워크 암호화가 감소한다",
      "choice4": "서브넷 분할이 불가능해진다",
      "answer": 1,
      "explanation": "NAT는 IP 변환으로 인해 P2P나 VoIP 등에서 연결 문제가 발생할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 41,
    "fields": {
      "question": "HTTPS 핸드셰이크에서 사용되는 공개키 암호화 방식의 목적은?",
      "choice1": "데이터 압축",
      "choice2": "라우팅 경로 설정",
      "choice3": "세션 키 교환",
      "choice4": "전송 속도 증가",
      "answer": 3,
      "explanation": "공개키는 대칭키(세션 키)를 안전하게 교환하는 데 사용된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 42,
    "fields": {
      "question": "스위치가 학습하지 않은 MAC 주소로 프레임을 받으면 수행하는 동작은?",
      "choice1": "라우터로 전달한다",
      "choice2": "버린다",
      "choice3": "모든 포트로 플러딩한다",
      "choice4": "출발 MAC만 기록하고 정지한다",
      "answer": 3,
      "explanation": "MAC 미학습 시 스위치는 일단 전체 포트로 전달해 목적지를 찾는다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 43,
    "fields": {
      "question": "DNS의 레코드 타입 중 도메인을 특정 IPv4 주소와 매핑하는 것은?",
      "choice1": "NS 레코드",
      "choice2": "MX 레코드",
      "choice3": "A 레코드",
      "choice4": "CNAME 레코드",
      "answer": 3,
      "explanation": "A 레코드는 IPv4 주소를 반환한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 44,
    "fields": {
      "question": "TCP 연결 종료 시 사용하는 메시지 조합은?",
      "choice1": "SYN / ACK",
      "choice2": "SYN / FIN",
      "choice3": "FIN / ACK",
      "choice4": "FIN / SYN",
      "answer": 3,
      "explanation": "연결 종료는 FIN과 ACK 교환으로 이루어진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 45,
    "fields": {
      "question": "DHCP 서버가 클라이언트에게 IP를 임대하는 과정의 첫 번째 단계는?",
      "choice1": "Request",
      "choice2": "Offer",
      "choice3": "Acknowledge",
      "choice4": "Discover",
      "answer": 4,
      "explanation": "클라이언트는 먼저 Discover 메시지를 브로드캐스트로 보낸다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 46,
    "fields": {
      "question": "CSMA/CD가 주로 사용되던 네트워크 매체는?",
      "choice1": "LTE 네트워크",
      "choice2": "무선 LAN",
      "choice3": "유선 이더넷",
      "choice4": "광 네트워크",
      "answer": 3,
      "explanation": "충돌 감지는 유선 이더넷에서 사용되며, 무선에서는 CSMA/CA가 쓰인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 47,
    "fields": {
      "question": "프록시 서버의 대표적 기능은 무엇인가?",
      "choice1": "ARP 테이블 관리",
      "choice2": "캐싱을 통한 성능 향상",
      "choice3": "MAC 주소 변환",
      "choice4": "라우팅 경로 설정",
      "answer": 2,
      "explanation": "프록시는 요청 결과를 캐싱하여 응답 속도를 개선한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 48,
    "fields": {
      "question": "Netstat 명령어의 주요 용도는?",
      "choice1": "DNS 서버 변경",
      "choice2": "네트워크 속도 측정",
      "choice3": "포트 및 연결 상태 확인",
      "choice4": "VLAN 구성",
      "answer": 3,
      "explanation": "netstat은 현재 사용 중인 포트와 연결 상태를 보여준다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 49,
    "fields": {
      "question": "MTU보다 큰 패킷을 처리할 수 없을 때 라우터가 수행하는 동작은?",
      "choice1": "자동 재조립",
      "choice2": "암호화 요청",
      "choice3": "ICMP Fragmentation Needed 메시지 전송",
      "choice4": "경로 변경",
      "answer": 3,
      "explanation": "라우터는 분할이 필요한 패킷에 대해 ICMP 오류 메시지를 보낸다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 50,
    "fields": {
      "question": "IPv6 주소 표현 방식 중 0을 축약하는 규칙으로 올바른 것은?",
      "choice1": "여러 번 :: 사용 가능",
      "choice2": "중간의 0만 제거할 수 있다",
      "choice3": "연속된 0 그룹은 :: 로 한 번만 축약 가능",
      "choice4": "0은 제거 불가",
      "answer": 3,
      "explanation": "::는 IPv6 주소에서 단 한 번만 사용할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 51,
    "fields": {
      "question": "스위치에서 STP(Spanning Tree Protocol)의 목적은?",
      "choice1": "IP 추적",
      "choice2": "MAC 주소 암호화",
      "choice3": "대역폭 증가",
      "choice4": "루프 방지",
      "answer": 4,
      "explanation": "STP는 스위치 간 루프를 제거하기 위해 특정 경로를 차단한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 52,
    "fields": {
      "question": "IPSec에서 AH(Authentication Header)가 제공하는 보안 기능은?",
      "choice1": "트랜스포트 계층 보호",
      "choice2": "암호화",
      "choice3": "경로 최적화",
      "choice4": "무결성 및 인증",
      "answer": 4,
      "explanation": "AH는 무결성과 인증을 제공하지만 암호화는 ESP가 담당한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 53,
    "fields": {
      "question": "CDN(Content Delivery Network)의 주요 목적은?",
      "choice1": "콘텐츠를 사용자와 가까운 서버에서 제공",
      "choice2": "브로드캐스트 트래픽 감소",
      "choice3": "DNS를 대체",
      "choice4": "네트워크 장비 비용 절감",
      "answer": 1,
      "explanation": "CDN은 지리적으로 가까운 서버에서 콘텐츠를 제공해 응답 속도를 개선한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 54,
    "fields": {
      "question": "ICMP의 주요 역할은?",
      "choice1": "데이터 암호화",
      "choice2": "오류 및 제어 메시지 전달",
      "choice3": "ARP 테이블 저장",
      "choice4": "세션 유지",
      "answer": 2,
      "explanation": "ICMP는 네트워크 오류 정보를 전달한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 55,
    "fields": {
      "question": "라우터가 목적지 네트워크를 모를 때 수행하는 동작은?",
      "choice1": "임의의 경로로 전달",
      "choice2": "기본 경로(Default Route)로 전달",
      "choice3": "DNS 서버로 전송",
      "choice4": "패킷을 모두 버린다",
      "answer": 2,
      "explanation": "기본 경로가 설정되어 있다면 해당 경로로 패킷이 전달된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 56,
    "fields": {
      "question": "SSL/TLS에서 사용되는 대칭키 암호화 방식의 장점은?",
      "choice1": "오류 제어가 필요 없다",
      "choice2": "키 교환이 간단하다",
      "choice3": "전송 속도가 빠르다",
      "choice4": "공격 방어에 절대적이다",
      "answer": 3,
      "explanation": "대칭키 방식은 암/복호화 속도가 빠른 것이 장점이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 57,
    "fields": {
      "question": "RARP의 주요 기능은 무엇인가?",
      "choice1": "DNS 서버 역할 수행",
      "choice2": "IP 주소를 MAC으로 변환",
      "choice3": "라우팅 정보를 교환",
      "choice4": "MAC 주소로 IP 주소를 알아낸다",
      "answer": 4,
      "explanation": "RARP는 MAC 주소만 알고 있을 때 IP를 요청하는 프로토콜이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 58,
    "fields": {
      "question": "ACL(Access Control List)의 사용 목적은?",
      "choice1": "MAC 학습",
      "choice2": "라우팅 경로 탐색",
      "choice3": "NAT 변환",
      "choice4": "트래픽 필터링",
      "answer": 4,
      "explanation": "ACL은 특정 트래픽을 허용하거나 차단하는 데 사용된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 59,
    "fields": {
      "question": "SSH의 특징으로 가장 적절한 것은?",
      "choice1": "라우팅 경로를 자동 구성",
      "choice2": "파일을 압축해서 전송",
      "choice3": "하드웨어 기반 인증만 사용",
      "choice4": "원격 접속 시 암호화된 통신을 제공",
      "answer": 4,
      "explanation": "SSH는 암호화된 원격 접속을 제공한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 60,
    "fields": {
      "question": "라우팅 프로토콜 중 거리 벡터 기반으로 동작하는 것은?",
      "choice1": "IS-IS",
      "choice2": "OSPF",
      "choice3": "EIGRP(하이브리드)",
      "choice4": "RIP",
      "answer": 4,
      "explanation": "RIP은 거리 벡터 기반으로 홉 수를 기준으로 경로를 선택한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 61,
    "fields": {
      "question": "BGP에서 경로 선택 시 가장 먼저 비교되는 항목은?",
      "choice1": "MED 값",
      "choice2": "AS-Path 길이",
      "choice3": "Local Preference",
      "choice4": "Weight 값",
      "answer": 4,
      "explanation": "BGP 경로 선택에서 Cisco 기준 Weight 값이 가장 우선 비교된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 62,
    "fields": {
      "question": "OSPF에서 DR/BDR 선출 시 가장 우선적으로 고려되는 값은?",
      "choice1": "Hello Timer",
      "choice2": "라우터 ID",
      "choice3": "코스트 값",
      "choice4": "인터페이스 Priority",
      "answer": 4,
      "explanation": "Priority가 가장 먼저 고려되며, 동일할 경우 라우터 ID로 결정된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 63,
    "fields": {
      "question": "MPLS에서 패킷 전달 시 사용되는 기본 정보 단위는?",
      "choice1": "Segment",
      "choice2": "Label",
      "choice3": "Channel",
      "choice4": "Frame ID",
      "answer": 2,
      "explanation": "MPLS는 패킷에 라벨을 부착해 Label Switching 방식으로 전달한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 64,
    "fields": {
      "question": "DNSSEC에서 데이터 위조를 방지하기 위해 사용하는 기술은?",
      "choice1": "토큰 기반 인증",
      "choice2": "대칭키 암호화",
      "choice3": "공개키 기반 전자서명",
      "choice4": "VPN 터널링",
      "answer": 3,
      "explanation": "DNSSEC은 리소스 레코드에 전자서명을 추가하여 위변조를 방지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 65,
    "fields": {
      "question": "TCP의 Fast Recovery 알고리즘이 실행되는 조건은?",
      "choice1": "연결 재설정 신호 감지",
      "choice2": "타임아웃 발생",
      "choice3": "MSS 변경 신호 감지",
      "choice4": "중복 ACK 세 개 수신",
      "answer": 4,
      "explanation": "중복 ACK 3개 수신 시 빠른 재전송 후 빠른 회복 알고리즘이 실행된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 66,
    "fields": {
      "question": "SDN에서 컨트롤 플레인 역할을 주로 담당하는 요소는?",
      "choice1": "스위치",
      "choice2": "DNS 서버",
      "choice3": "라우터",
      "choice4": "SDN 컨트롤러",
      "answer": 4,
      "explanation": "SDN 컨트롤러가 네트워크의 중앙 지휘 역할을 하며 정책과 경로를 제어한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 67,
    "fields": {
      "question": "QUIC 프로토콜의 특징으로 가장 적절한 것은?",
      "choice1": "TCP 대신 UDP 기반에서 TLS를 통합하여 동작",
      "choice2": "라우터에서 경로 최적화를 수행",
      "choice3": "전송 계층이 아닌 네트워크 계층에서 수행된다",
      "choice4": "HTTP/2만 지원",
      "answer": 1,
      "explanation": "QUIC은 UDP 기반에서 TLS 암호화를 포함한 신속한 연결을 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 68,
    "fields": {
      "question": "IPv6 Neighbor Discovery Protocol(NDP)의 기능이 아닌 것은?",
      "choice1": "이웃 MAC 주소 발견",
      "choice2": "중복 주소 감지",
      "choice3": "주소 자동 구성",
      "choice4": "경로 선택",
      "answer": 4,
      "explanation": "경로 선택은 라우팅 프로토콜의 역할이며 NDP 기능이 아니다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 69,
    "fields": {
      "question": "TLS Handshake 중 Perfect Forward Secrecy(PFS)를 제공하려면 어떤 메커니즘이 필요한가?",
      "choice1": "RSA 단독 암호화",
      "choice2": "Ephemeral Diffie-Hellman",
      "choice3": "IKEv1",
      "choice4": "AES-CBC",
      "answer": 2,
      "explanation": "Ephemeral DH(ECDHE)를 사용해야 세션 키 노출을 방지할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 70,
    "fields": {
      "question": "VXLAN에서 L2 네트워크 확장을 위해 사용하는 기술은?",
      "choice1": "MAC-in-UDP 캡슐화",
      "choice2": "MSS 조정",
      "choice3": "AAA 인증",
      "choice4": "라우팅 테이블 분할",
      "answer": 1,
      "explanation": "VXLAN은 L2 프레임을 UDP 안에 캡슐화하여 가상 네트워크를 형성한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 71,
    "fields": {
      "question": "BGP에서 루프 방지를 위해 사용하는 메커니즘은?",
      "choice1": "Hello 메시지",
      "choice2": "Hold Timer",
      "choice3": "AS-Path",
      "choice4": "TTL Decrement",
      "answer": 3,
      "explanation": "AS-Path에 포함된 자신의 AS 번호가 있으면 루프로 판단한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 72,
    "fields": {
      "question": "TCP의 TIME-WAIT 상태가 중요한 이유는?",
      "choice1": "ARP 캐시를 유지하기 위해",
      "choice2": "지연된 패킷이 새 연결에 영향을 주지 않도록 하기 위해",
      "choice3": "라우터 성능을 높이기 위해",
      "choice4": "연결 속도를 높이기 위해",
      "answer": 2,
      "explanation": "TIME-WAIT는 오래된 패킷이 새로운 연결로 잘못 해석되는 것을 방지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 73,
    "fields": {
      "question": "라우팅 프로토콜 중 링크 상태 알고리즘에 기반한 것은?",
      "choice1": "RIP",
      "choice2": "BGP",
      "choice3": "OSPF",
      "choice4": "EIGRP",
      "answer": 3,
      "explanation": "링크 상태 방식은 네트워크 전체 토폴로지를 활용하는 OSPF가 대표적이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 74,
    "fields": {
      "question": "IPSec의 ESP가 제공하지 않는 기능은?",
      "choice1": "인증",
      "choice2": "라우팅 최적화",
      "choice3": "기밀성",
      "choice4": "무결성",
      "answer": 2,
      "explanation": "ESP는 암호화와 무결성·인증을 제공하나 라우팅 기능은 없다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 75,
    "fields": {
      "question": "MPLS에서 Control Plane과 Data Plane이 상호작용하는 방식으로 가장 적절한 것은?",
      "choice1": "Data Plane이 라벨을 생성하고 Control Plane이 전달",
      "choice2": "둘 다 라우팅 정보만 교환",
      "choice3": "둘 다 스위칭만 수행",
      "choice4": "Control Plane이 LSP를 설정하고 Data Plane이 라벨 기반으로 전달",
      "answer": 4,
      "explanation": "Control Plane은 경로 설정, Data Plane은 라벨 스위칭을 수행한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 76,
    "fields": {
      "question": "HTTP/3가 HTTP/2와 근본적으로 다른 점은?",
      "choice1": "전송 계층을 QUIC 기반으로 변경",
      "choice2": "스트림을 지원하지 않는다",
      "choice3": "TLS를 사용하지 않는다",
      "choice4": "서버 푸시 기능이 없다",
      "answer": 1,
      "explanation": "HTTP/3는 TCP가 아닌 QUIC(UDP 기반)에서 동작한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 77,
    "fields": {
      "question": "SD-WAN이 기존 WAN 대비 제공하는 주요 이점은?",
      "choice1": "라우터를 제거",
      "choice2": "모든 트래픽을 반드시 MPLS로 전달",
      "choice3": "경로 선택을 애플리케이션 레벨에서 수행",
      "choice4": "IPv6만 지원",
      "answer": 3,
      "explanation": "SD-WAN은 트래픽의 우선순위와 애플리케이션 특성을 기반으로 경로를 동적으로 최적화한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 78,
    "fields": {
      "question": "Ethernet에서 Jumbo Frame의 목적은?",
      "choice1": "CPU 처리 부담 감소",
      "choice2": "ARP 사용량 감소",
      "choice3": "라우팅 성능 증가",
      "choice4": "보안 강화",
      "answer": 1,
      "explanation": "더 큰 프레임을 사용해 CPU 부하와 인터럽트 발생을 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 79,
    "fields": {
      "question": "라우터가 경로 재분배(Route Redistribution)를 수행할 때 발생할 수 있는 문제는?",
      "choice1": "케이블 손상",
      "choice2": "루프 생성",
      "choice3": "MAC 테이블 손실",
      "choice4": "포트 미러링 실패",
      "answer": 2,
      "explanation": "잘못된 재분배는 라우팅 루프나 불안정성을 초래할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 80,
    "fields": {
      "question": "IEEE 802.1X에서 EAPOL이 수행하는 역할은?",
      "choice1": "VPN 터널 생성",
      "choice2": "ARP 요청 대체",
      "choice3": "인증 프레임 전달",
      "choice4": "라우팅 경로 계산",
      "answer": 3,
      "explanation": "EAPOL은 스위치와 클라이언트 간 인증 정보를 교환한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 81,
    "fields": {
      "question": "QoS에서 DiffServ의 핵심 개념은?",
      "choice1": "패킷 크기 증가",
      "choice2": "DSCP 값 기반 트래픽 분류",
      "choice3": "암호화 자동 적용",
      "choice4": "MAC 주소 기반 분류",
      "answer": 2,
      "explanation": "DiffServ는 DSCP 필드를 통해 서비스 우선순위를 지정한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 82,
    "fields": {
      "question": "라우터에서 Equal-Cost Multi-Path(ECMP)의 목적은?",
      "choice1": "암호화",
      "choice2": "브로드캐스트 관리",
      "choice3": "장비 인증",
      "choice4": "부하 분산",
      "answer": 4,
      "explanation": "ECMP는 동일 코스트 경로가 여러 개 있을 때 부하를 분산한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 83,
    "fields": {
      "question": "STP의 RSTP로의 개선 사항 중 하나는?",
      "choice1": "MAC 주소 암호화",
      "choice2": "포트 개수 축소",
      "choice3": "패킷 필터링 자동화",
      "choice4": "수렴 속도 증가",
      "answer": 4,
      "explanation": "RSTP는 STP보다 훨씬 빠른 수렴 속도를 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 84,
    "fields": {
      "question": "LISP(Locator/ID Separation Protocol)의 주요 목적은?",
      "choice1": "엔드포인트 식별자와 위치 정보를 분리",
      "choice2": "DNS를 대체하기 위해",
      "choice3": "ARP를 제거",
      "choice4": "라우터를 단순화",
      "answer": 1,
      "explanation": "LISP는 ID와 Locator를 분리하여 확장성 있는 네트워크 구조를 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 85,
    "fields": {
      "question": "BGP에서 Route Flapping을 억제하기 위한 메커니즘은?",
      "choice1": "Split Horizon",
      "choice2": "Poison Reverse",
      "choice3": "Route Dampening",
      "choice4": "TTL-Security",
      "answer": 3,
      "explanation": "Route Dampening은 잦은 경로 변경을 억제한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 86,
    "fields": {
      "question": "TCP의 SACK 옵션이 제공하는 이점은?",
      "choice1": "혼잡 윈도우 제거",
      "choice2": "3-way handshake 제거",
      "choice3": "암호화 수준 강화",
      "choice4": "선택적 재전송을 통해 성능 향상",
      "answer": 4,
      "explanation": "SACK은 손실된 부분만 재전송하여 효율을 높인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 87,
    "fields": {
      "question": "IPv6에서 Anycast 주소의 주요 특징은?",
      "choice1": "가장 가까운 노드로 패킷이 전달된다",
      "choice2": "멀티캐스트보다 우선 순위가 낮다",
      "choice3": "지정된 노드로만 전달된다",
      "choice4": "모든 노드에게 브로드캐스트된다",
      "answer": 1,
      "explanation": "Anycast는 여러 수신자 중 가장 가까운 노드로 전달된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 88,
    "fields": {
      "question": "SSL/TLS에서 Record Layer의 역할은?",
      "choice1": "TLS 종료 트리거",
      "choice2": "핸드셰이크 수행",
      "choice3": "데이터 암호화 및 무결성 제공",
      "choice4": "라우팅 경로 생성",
      "answer": 3,
      "explanation": "Record Layer는 실제 응용 데이터에 대한 암호화와 인증을 처리한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 89,
    "fields": {
      "question": "IEEE 802.11에서 OFDM을 사용하는 주요 목적은?",
      "choice1": "멀티패스 간섭 최소화",
      "choice2": "보안 강화",
      "choice3": "송신 전력 증가",
      "choice4": "MAC 계층 단순화",
      "answer": 1,
      "explanation": "OFDM은 다중 경로 간섭을 줄여 무선 성능을 향상시킨다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 90,
    "fields": {
      "question": "TCP 기반 애플리케이션이 높은 지연 환경에서 성능이 저하되는 이유는?",
      "choice1": "DNS 캐시 실패",
      "choice2": "윈도우 기반 흐름 제어의 한계",
      "choice3": "ARP 충돌",
      "choice4": "MAC 주소 검색 지연",
      "answer": 2,
      "explanation": "RTT가 증가하면 슬라이딩 윈도우 기반 전송량이 제한된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 1,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 91,
    "fields": {
      "question": "운영체제가 CPU 시간을 여러 프로세스에 나누어 주는 방식을 무엇이라 하는가?",
      "choice1": "다중 프로그래밍",
      "choice2": "일괄 처리",
      "choice3": "시분할",
      "choice4": "단일 태스킹",
      "answer": 3,
      "explanation": "시분할은 여러 프로그램이 CPU를 조금씩 나누어 사용하는 방식이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 92,
    "fields": {
      "question": "프로세스의 실행 상태 중 CPU를 얻어 실제로 명령을 수행하는 상태는?",
      "choice1": "Running",
      "choice2": "Waiting",
      "choice3": "Ready",
      "choice4": "Blocked",
      "answer": 1,
      "explanation": "Running 상태는 실제로 CPU를 사용하여 명령을 실행하는 단계이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 93,
    "fields": {
      "question": "운영체제에서 메모리 보호를 위해 사용하는 기본적인 하드웨어 장치는?",
      "choice1": "DMA 컨트롤러",
      "choice2": "캐시 컨트롤러",
      "choice3": "베이스/리미트 레지스터",
      "choice4": "ALU",
      "answer": 3,
      "explanation": "베이스/리미트 레지스터는 프로세스가 접근할 수 있는 메모리 범위를 제한한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 94,
    "fields": {
      "question": "스레드가 프로세스보다 가볍다고 하는 이유는 무엇인가?",
      "choice1": "커널이 아닌 사용자만 사용하기 때문이다",
      "choice2": "더 많은 메모리를 사용하기 때문이다",
      "choice3": "문맥 교환 비용이 적다",
      "choice4": "프로세스보다 느리기 때문이다",
      "answer": 3,
      "explanation": "스레드는 프로세스 내 자원을 공유하므로 문맥 교환 비용이 훨씬 적다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 95,
    "fields": {
      "question": "CPU 스케줄링에서 선점형 스케줄링 방식의 특징은?",
      "choice1": "실행 중인 프로세스를 중단할 수 없다",
      "choice2": "실행 중인 프로세스를 중단할 수 있다",
      "choice3": "배치 처리에만 사용된다",
      "choice4": "항상 우선순위가 낮은 작업이 먼저 실행된다",
      "answer": 2,
      "explanation": "선점형 방식은 더 높은 우선순위가 오면 현재 실행 프로세스를 중단할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 96,
    "fields": {
      "question": "페이징 기법에서 고정 크기의 메모리 단위를 무엇이라 하는가?",
      "choice1": "세그먼트",
      "choice2": "블록",
      "choice3": "페이지",
      "choice4": "슬롯",
      "answer": 3,
      "explanation": "페이징은 메모리를 동일한 크기의 페이지 단위로 나누는 메모리 관리 기법이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 97,
    "fields": {
      "question": "운영체제가 하드웨어와 사용자 프로그램 사이에서 중개 역할을 하는 핵심 소프트웨어를 무엇이라 하는가?",
      "choice1": "커널",
      "choice2": "펌웨어",
      "choice3": "드라이버",
      "choice4": "부트로더",
      "answer": 1,
      "explanation": "커널은 운영체제의 핵심 구성요소로 CPU, 메모리, 디스크 등을 관리한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 98,
    "fields": {
      "question": "파일 시스템에서 디렉터리의 역할은 무엇인가?",
      "choice1": "네트워크를 초기화한다",
      "choice2": "파일을 그룹화하고 관리한다",
      "choice3": "파일 내용을 압축한다",
      "choice4": "프로세스를 종료한다",
      "answer": 2,
      "explanation": "디렉터리는 파일을 구조적으로 정리하는 역할을 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 99,
    "fields": {
      "question": "마우스, 키보드 등 입출력 장치를 효율적으로 관리하기 위해 운영체제가 사용하는 구조는?",
      "choice1": "장치 드라이버",
      "choice2": "교착 방지기",
      "choice3": "코어 스레드",
      "choice4": "파이프 라인",
      "answer": 1,
      "explanation": "장치 드라이버는 OS와 하드웨어 장치 간 인터페이스 역할을 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 100,
    "fields": {
      "question": "교착 상태(Deadlock)가 발생하기 위한 4가지 조건 중 하나는?",
      "choice1": "우선순위 상승",
      "choice2": "상호 배제",
      "choice3": "동기화 해제",
      "choice4": "비순차 실행",
      "answer": 2,
      "explanation": "교착 상태는 상호 배제, 점유와 대기, 비선점, 순환 대기의 4조건이 모두 만족해야 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 101,
    "fields": {
      "question": "PCB(Process Control Block)가 저장하는 정보가 아닌 것은?",
      "choice1": "그래픽 카드 프레임 정보",
      "choice2": "레지스터 값",
      "choice3": "메모리 위치 정보",
      "choice4": "프로세스 상태",
      "answer": 1,
      "explanation": "PCB는 프로세스 관리 정보를 저장하며 그래픽 프레임 정보는 포함하지 않는다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 102,
    "fields": {
      "question": "가상 메모리 시스템에서 페이지 부재(Page Fault)가 발생하면 필요한 작업은?",
      "choice1": "프로그램을 강제 종료한다",
      "choice2": "CPU를 재부팅한다",
      "choice3": "디스크에서 페이지를 불러온다",
      "choice4": "캐시 메모리를 삭제한다",
      "answer": 3,
      "explanation": "페이지가 메모리에 없을 때 디스크에서 해당 페이지를 로드한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 103,
    "fields": {
      "question": "스케줄링 정책 중 짧은 작업을 우선 실행시키는 방식은?",
      "choice1": "SJF",
      "choice2": "RR",
      "choice3": "FIFO",
      "choice4": "FCFS",
      "answer": 1,
      "explanation": "SJF(Shortest Job First)는 실행 시간이 가장 짧은 프로세스를 먼저 수행한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 104,
    "fields": {
      "question": "운영체제의 부팅 과정에서 가장 먼저 실행되는 프로그램은?",
      "choice1": "부트로더",
      "choice2": "커널 스레드",
      "choice3": "파일 시스템",
      "choice4": "쉘",
      "answer": 1,
      "explanation": "부트로더는 커널을 메모리에 적재하는 초기 프로그램이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 105,
    "fields": {
      "question": "사용자와 운영체제 간 명령을 입력하고 결과를 출력하는 인터페이스는?",
      "choice1": "디스패처",
      "choice2": "캐시",
      "choice3": "쉘(Shell)",
      "choice4": "버퍼",
      "answer": 3,
      "explanation": "쉘은 사용자의 명령을 해석하여 운영체제 기능을 호출한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 106,
    "fields": {
      "question": "프로세스 간 통신(IPC) 방식 중 공유 메모리의 특징은?",
      "choice1": "가장 빠른 통신 방식이다",
      "choice2": "데이터를 파일 단위로만 주고받는다",
      "choice3": "별도의 스케줄러가 필요하다",
      "choice4": "항상 커널을 통해서만 통신한다",
      "answer": 1,
      "explanation": "공유 메모리는 메모리를 직접 공유하여 매우 빠른 IPC 방식이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 107,
    "fields": {
      "question": "CPU의 이용률을 높이고 여러 프로그램을 동시에 실행하는 것처럼 보이게 하는 개념은?",
      "choice1": "순차 처리",
      "choice2": "하이퍼 스레딩",
      "choice3": "싱글 스레딩",
      "choice4": "멀티태스킹",
      "answer": 4,
      "explanation": "멀티태스킹은 여러 작업이 동시에 실행되는 것처럼 보이도록 CPU를 분할하여 운영한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 108,
    "fields": {
      "question": "운영체제에서 인터럽트가 발생했을 때 가장 먼저 수행되는 것은?",
      "choice1": "현재 실행 상태 저장",
      "choice2": "커널 교체",
      "choice3": "프로세스 종료",
      "choice4": "디스크 포맷",
      "answer": 1,
      "explanation": "인터럽트 발생 시 CPU는 먼저 현재 상태를 저장한 뒤 처리 루틴으로 이동한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 109,
    "fields": {
      "question": "CPU가 다음에 실행할 명령의 주소를 저장하는 레지스터는?",
      "choice1": "IR",
      "choice2": "PC(Program Counter)",
      "choice3": "FLAG",
      "choice4": "ACC",
      "answer": 2,
      "explanation": "PC는 다음에 실행할 명령의 주소를 저장한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 110,
    "fields": {
      "question": "세마포어의 주요 목적은 무엇인가?",
      "choice1": "파일 압축",
      "choice2": "프로세스 간 동기화",
      "choice3": "메모리 교체 가속",
      "choice4": "네트워크 패킷 분석",
      "answer": 2,
      "explanation": "세마포어는 동시 자원 접근을 제어하는 동기화 도구이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 111,
    "fields": {
      "question": "스케줄링에서 Round Robin 방식의 핵심 요소는?",
      "choice1": "우선순위만 고려",
      "choice2": "배치 처리",
      "choice3": "타임 퀀텀",
      "choice4": "메모리 조각화",
      "answer": 3,
      "explanation": "RR 스케줄링은 일정한 시간 단위(타임 퀀텀)를 기준으로 프로세스를 교대 실행한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 112,
    "fields": {
      "question": "메모리 단편화 중 물리적 공간이 여러 조각으로 나누어져 사용하지 못하는 현상은?",
      "choice1": "외부 단편화",
      "choice2": "프레임 오류",
      "choice3": "내부 단편화",
      "choice4": "페이지 아웃",
      "answer": 1,
      "explanation": "외부 단편화는 비어 있는 공간이 연속적이지 않아 사용할 수 없는 상태를 말한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 113,
    "fields": {
      "question": "하드디스크에서 데이터를 읽을 때 가장 오래 걸리는 시간 요소는?",
      "choice1": "전송 속도",
      "choice2": "캐시 적중 시간",
      "choice3": "버퍼링 시간",
      "choice4": "탐색 시간(Seek Time)",
      "answer": 4,
      "explanation": "탐색 시간은 헤드를 원하는 위치로 이동시키는 데 걸리는 시간으로 가장 큰 비중을 차지한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 114,
    "fields": {
      "question": "운영체제에서 프로세스를 생성하는 명령어 또는 시스템 호출은?",
      "choice1": "fork",
      "choice2": "open",
      "choice3": "sleep",
      "choice4": "join",
      "answer": 1,
      "explanation": "Unix 계열 OS에서 fork는 새로운 프로세스를 생성한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 115,
    "fields": {
      "question": "커널 모드와 사용자 모드를 구분하는 이유는?",
      "choice1": "시스템 보호를 위해",
      "choice2": "캐시 메모리를 줄이기 위해",
      "choice3": "CPU 속도를 높이기 위해",
      "choice4": "네트워크 기능을 추가하기 위해",
      "answer": 1,
      "explanation": "커널 모드는 시스템 자원을 보호하기 위한 권한 모드이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 116,
    "fields": {
      "question": "페이지 교체 알고리즘 중 가장 오래 사용되지 않은 페이지를 제거하는 방식은?",
      "choice1": "OPT",
      "choice2": "LFU",
      "choice3": "FIFO",
      "choice4": "LRU",
      "answer": 4,
      "explanation": "LRU는 가장 오랫동안 참조되지 않은 페이지를 교체한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 117,
    "fields": {
      "question": "운영체제에서 프로세스가 I/O 작업을 요청하면 어떤 상태로 전환되는가?",
      "choice1": "Running",
      "choice2": "Blocked",
      "choice3": "Ready",
      "choice4": "Zombie",
      "answer": 2,
      "explanation": "I/O 완료를 기다리기 위해 Blocked 상태로 전환된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 118,
    "fields": {
      "question": "파일 시스템에서 파일의 실제 저장 위치 목록을 저장하는 구조는?",
      "choice1": "pipe",
      "choice2": "i-node",
      "choice3": "mutex",
      "choice4": "heap",
      "answer": 2,
      "explanation": "i-node는 파일의 메타정보 및 데이터 블록 위치를 저장한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 119,
    "fields": {
      "question": "스레드가 프로세스와 공유하는 자원이 아닌 것은?",
      "choice1": "파일 디스크립터",
      "choice2": "스택",
      "choice3": "데이터",
      "choice4": "코드",
      "answer": 2,
      "explanation": "스레드는 코드/데이터/파일은 공유하지만 스택은 독립적으로 가진다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 120,
    "fields": {
      "question": "멀티프로세싱의 장점으로 가장 적절한 것은?",
      "choice1": "메모리 사용량 증가",
      "choice2": "프로세스 전환 불가",
      "choice3": "인터럽트 제거",
      "choice4": "프로그램 병렬 실행",
      "answer": 4,
      "explanation": "멀티프로세싱은 여러 CPU를 사용해 병렬 실행을 가능하게 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 121,
    "fields": {
      "question": "운영체제에서 스레드보다 프로세스 문맥 교환(Context Switch)이 더 비용이 큰 이유는?",
      "choice1": "커널 모드 전환이 없기 때문",
      "choice2": "레지스터 저장이 필요 없기 때문에",
      "choice3": "독립적인 메모리 공간을 모두 교체해야 해서",
      "choice4": "스택만 교체하면 되기 때문에",
      "answer": 3,
      "explanation": "프로세스는 메모리 영역 전체가 독립적이므로 문맥 교환 시 비용이 크다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 122,
    "fields": {
      "question": "은행원 알고리즘(Banker's Algorithm)의 주 목적은?",
      "choice1": "교착 상태 예방",
      "choice2": "프로세스 우선순위 증가",
      "choice3": "메모리 단편화 제거",
      "choice4": "캐시 지역성 향상",
      "answer": 1,
      "explanation": "은행원 알고리즘은 교착 상태가 발생하지 않도록 안전 상태를 유지한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 123,
    "fields": {
      "question": "세그멘테이션(segmentation) 방식의 주요 특징은?",
      "choice1": "가변 크기의 논리적 단위로 메모리를 분할한다",
      "choice2": "프로세스 간 메모리를 완전히 공유한다",
      "choice3": "고정 크기의 페이지 단위를 사용한다",
      "choice4": "스와핑이 불가능하다",
      "answer": 1,
      "explanation": "세그멘테이션은 코드/데이터 등 논리적 단위별로 메모리를 나누는 방식이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 124,
    "fields": {
      "question": "멀티레벨 큐 스케줄링의 특징은?",
      "choice1": "교착 상태 방지가 기본 기능이다",
      "choice2": "큐 간 이동이 허용되지 않는 경우가 많다",
      "choice3": "단일 우선순위만 지원한다",
      "choice4": "모든 프로세스가 하나의 큐만 사용한다",
      "answer": 2,
      "explanation": "멀티레벨 큐는 큐가 고정되어 이동이 제한되는 특징이 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 125,
    "fields": {
      "question": "Copy-on-Write(COW) 기술이 사용되는 이유는?",
      "choice1": "프로세스 간 메모리 복사를 지연시켜 성능을 높이기 위해",
      "choice2": "CPU 스케줄링을 단순화하기 위해",
      "choice3": "캐시를 비활성화하기 위해",
      "choice4": "메모리 크기를 줄이기 위해",
      "answer": 1,
      "explanation": "COW는 실제로 수정이 발생할 때만 페이지를 복사함으로써 효율성을 높인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 126,
    "fields": {
      "question": "페이지 교체 알고리즘 중 Belady’s anomaly가 발생할 수 있는 방식은?",
      "choice1": "OPT",
      "choice2": "FIFO",
      "choice3": "LRU",
      "choice4": "Clock",
      "answer": 2,
      "explanation": "FIFO는 프레임 수 증가에도 페이지 폴트가 증가할 수 있는 Belady anomaly가 발생한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 127,
    "fields": {
      "question": "I/O 버퍼링에서 더블 버퍼(Double Buffer)의 장점은?",
      "choice1": "입출력 장치 대기 시간을 줄일 수 있다",
      "choice2": "메모리를 절반만 사용한다",
      "choice3": "프로세스 동기화가 필요 없다",
      "choice4": "캐시를 대체할 수 있다",
      "answer": 1,
      "explanation": "더블 버퍼는 한 버퍼가 처리되는 동안 다른 버퍼를 준비해 대기 시간을 줄인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 128,
    "fields": {
      "question": "스레드 풀(Thread Pool)의 주 목적은?",
      "choice1": "프로세스 생성 자동화",
      "choice2": "스레드 생성 비용 감소",
      "choice3": "커널 모드 진입 억제",
      "choice4": "메모리 파편화 제거",
      "answer": 2,
      "explanation": "스레드를 매번 생성하지 않고 재사용하여 오버헤드를 줄이는 구조다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 129,
    "fields": {
      "question": "인터럽트 벡터 테이블의 역할은?",
      "choice1": "각 인터럽트 요청에 대한 처리 루틴 주소를 저장",
      "choice2": "파일 시스템 루트를 관리",
      "choice3": "가상 메모리 크기를 설정",
      "choice4": "프로세스 우선순위를 관리",
      "answer": 1,
      "explanation": "인터럽트 벡터는 인터럽트 번호와 ISR 주소를 매핑하는 테이블이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 130,
    "fields": {
      "question": "소프트웨어 인터럽트(Trap)의 주요 용도는?",
      "choice1": "네트워크 충돌 해결",
      "choice2": "전원 공급 중단 감지",
      "choice3": "시스템 콜 처리",
      "choice4": "디스크 오류 감지",
      "answer": 3,
      "explanation": "Trap은 사용자 프로그램이 커널 기능을 요청할 때 발생한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 131,
    "fields": {
      "question": "스케줄러 중 장기 스케줄러의 역할은?",
      "choice1": "CPU 타임 슬라이스를 관리",
      "choice2": "I/O 우선순위를 조정",
      "choice3": "어떤 작업을 메모리에 적재할지 결정",
      "choice4": "프로세스 종료 시 자원 해제",
      "answer": 3,
      "explanation": "장기 스케줄러는 어떤 프로세스를 메모리에 들여보낼지를 결정한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 132,
    "fields": {
      "question": "페이지 테이블 엔트리(PTE)에 포함되지 않는 정보는?",
      "choice1": "사용자 계정 정보",
      "choice2": "참조 비트",
      "choice3": "프레임 번호",
      "choice4": "유효 비트",
      "answer": 1,
      "explanation": "페이지 테이블은 메모리 매핑 정보만 저장하며 사용자 정보는 포함하지 않는다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 133,
    "fields": {
      "question": "시스템 콜(System Call)이 필요한 이유는?",
      "choice1": "사용자가 커널 기능에 안전하게 접근하도록 하기 위해",
      "choice2": "메모리 사용을 줄이기 위해",
      "choice3": "프로그램 속도를 낮추기 위해",
      "choice4": "캐시 적중률을 높이기 위해",
      "answer": 1,
      "explanation": "시스템 콜은 사용자 프로그램이 커널 기능을 안전하게 사용할 수 있게 한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 134,
    "fields": {
      "question": "스케줄링에서 Aging 기법을 사용하는 목적은?",
      "choice1": "프로세스 종료 속도를 증가",
      "choice2": "파일 캐싱 향상",
      "choice3": "메모리 단편화 방지",
      "choice4": "기아(starvation)를 방지하기 위해",
      "answer": 4,
      "explanation": "Aging은 오래 기다린 프로세스의 우선순위를 점진적으로 높여 기아 문제를 해결한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 135,
    "fields": {
      "question": "운영체제의 커널 구조 중 마이크로커널의 장점은?",
      "choice1": "모든 기능을 하나로 통합",
      "choice2": "더 빠른 시스템 콜",
      "choice3": "응용 프로그램이 직접 하드웨어 제어",
      "choice4": "높은 안정성과 모듈성",
      "answer": 4,
      "explanation": "마이크로커널은 핵심 기능만 유지해 안정성과 확장성을 높인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 136,
    "fields": {
      "question": "파일 시스템에서 journaling 방식의 목적은?",
      "choice1": "프로세스 수를 줄이기 위해",
      "choice2": "시스템 오류 발생 시 복구를 빠르게 하기 위해",
      "choice3": "캐시를 비활성화하기 위해",
      "choice4": "파일 크기를 줄이기 위해",
      "answer": 2,
      "explanation": "journaling은 변경 로그를 저장하여 시스템 충돌 시 복구를 쉽게 한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 137,
    "fields": {
      "question": "DMA(Direct Memory Access)의 주요 장점은?",
      "choice1": "I/O 장치가 CPU를 제어",
      "choice2": "CPU를 거치지 않고 I/O 장치가 메모리에 직접 접근",
      "choice3": "메모리가 자동으로 압축",
      "choice4": "CPU가 모든 데이터 전송을 처리",
      "answer": 2,
      "explanation": "DMA는 장치가 메모리에 직접 접근하여 CPU 부하를 줄인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 138,
    "fields": {
      "question": "쓰레싱(Thrashing)이 발생하는 주요 원인은?",
      "choice1": "CPU가 과열될 때",
      "choice2": "페이지 폴트가 과도하게 발생할 때",
      "choice3": "캐시가 비어 있을 때",
      "choice4": "프로세스 우선순위가 너무 낮을 때",
      "answer": 2,
      "explanation": "페이지 폴트가 잦아 CPU가 실제 작업보다 페이지 교체에 시간을 많이 쓰는 상태가 쓰레싱이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 139,
    "fields": {
      "question": "메모리 접근에서 TLB의 주요 기능은?",
      "choice1": "인터럽트 우선순위 결정",
      "choice2": "CPU 스케줄링",
      "choice3": "가상 주소를 물리 주소로 빠르게 변환",
      "choice4": "디스크 조각 모음",
      "answer": 3,
      "explanation": "TLB는 페이지 테이블 캐시로 주소 변환 속도를 향상시킨다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 140,
    "fields": {
      "question": "UNIX에서 exec 시스템 호출의 특징은?",
      "choice1": "새로운 프로세스를 생성한다",
      "choice2": "기존 프로세스의 메모리를 새로운 프로그램으로 완전히 교체한다",
      "choice3": "프로세스를 일시 중단한다",
      "choice4": "커널을 재부팅한다",
      "answer": 2,
      "explanation": "exec는 fork와 달리 기존 프로세스의 내용을 새로운 프로그램으로 덮어쓴다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 141,
    "fields": {
      "question": "파일 시스템에서 inode가 저장하는 정보는?",
      "choice1": "실행 권한과 사용자 비밀번호",
      "choice2": "파일의 메타데이터",
      "choice3": "파일 내용 전체",
      "choice4": "운영체제 설정",
      "answer": 2,
      "explanation": "inode는 파일의 크기, 권한, 데이터 블록 주소 등의 메타 정보를 담는다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 142,
    "fields": {
      "question": "교착 상태 해결 기법 중 탐지(Detection) 방식의 특징은?",
      "choice1": "교착 상태를 절대 허용하지 않는다",
      "choice2": "모든 자원을 미리 확보해야 한다",
      "choice3": "교착 상태 발생 후 이를 감지한다",
      "choice4": "은행원 알고리즘을 항상 사용한다",
      "answer": 3,
      "explanation": "Detection 방식은 교착 상태 발생을 허용하고 이후 해결 절차를 수행한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 143,
    "fields": {
      "question": "멀티프로세싱 시스템에서 SMP(Symmetric Multiprocessing)의 특징은?",
      "choice1": "CPU 간 메모리 공유가 불가능",
      "choice2": "하나의 스케줄러만 동작",
      "choice3": "한 CPU만 커널 코드를 실행",
      "choice4": "모든 CPU가 동일한 권한으로 운영체제 자원 공유",
      "answer": 4,
      "explanation": "SMP는 모든 CPU가 대등하게 메모리와 자원을 공유한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 144,
    "fields": {
      "question": "Preemptive 스케줄링의 단점은?",
      "choice1": "교착 상태 항상 발생",
      "choice2": "프로세스 종료 불가",
      "choice3": "문맥 교환 비용 증가",
      "choice4": "I/O 효율 감소",
      "answer": 3,
      "explanation": "실행 중 프로세스를 중단하므로 문맥 교환 비용이 증가한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 145,
    "fields": {
      "question": "페이지 교체 알고리즘 Clock 방식의 핵심 개념은?",
      "choice1": "우선순위 기반 페이지 제거",
      "choice2": "참조 비트를 원형 큐 형태로 검사",
      "choice3": "가장 최근에 참조된 페이지 제거",
      "choice4": "가장 오래된 페이지 제거",
      "answer": 2,
      "explanation": "Clock 알고리즘은 참조 비트를 확인하며 원형 큐 형태로 페이지를 교체한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 146,
    "fields": {
      "question": "하드 링크(Hard Link)의 제한 사항은?",
      "choice1": "읽기 전용 파일에만 가능",
      "choice2": "다른 파일 시스템 간 연결 불가",
      "choice3": "동일 디렉터리에서만 생성 가능",
      "choice4": "항상 메타데이터를 복사해야 함",
      "answer": 2,
      "explanation": "하드 링크는 같은 파일 시스템 내에서만 생성할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 147,
    "fields": {
      "question": "스레드 동기화 문제에서 발생하는 경쟁 상태(Race Condition)의 원인은?",
      "choice1": "우선순위가 낮기 때문",
      "choice2": "I/O 속도가 느리기 때문",
      "choice3": "공유 자원 접근 시 순서가 보장되지 않기 때문",
      "choice4": "메모리 크기가 부족하기 때문",
      "answer": 3,
      "explanation": "경쟁 상태는 여러 스레드가 동시에 공유 자원을 접근할 때 순서가 보장되지 않아 발생한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 148,
    "fields": {
      "question": "RAID 1의 주요 기능은?",
      "choice1": "미러링을 통한 데이터 신뢰성 향상",
      "choice2": "성능 최적화만 제공",
      "choice3": "데이터 스트리핑",
      "choice4": "패리티 기반 복구",
      "answer": 1,
      "explanation": "RAID 1은 디스크를 복제하여 데이터 안정성을 크게 높인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 149,
    "fields": {
      "question": "우선순위 스케줄링에서 기아(starvation)가 발생하는 원인은?",
      "choice1": "프로세스 수가 적기 때문",
      "choice2": "메모리 누수",
      "choice3": "CPU 시간이 부족",
      "choice4": "우선순위가 낮은 프로세스가 계속 선택되지 않기 때문",
      "answer": 4,
      "explanation": "낮은 우선순위 프로세스가 CPU를 배정받지 못해 기아가 발생한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 150,
    "fields": {
      "question": "운영체제에서 Lazy Loading 기법을 사용하는 이유는?",
      "choice1": "모든 페이지를 미리 로드하기 위해",
      "choice2": "디스크 접근을 제거하기 위해",
      "choice3": "프로그램 실행 속도를 무조건 빠르게 하기 위해",
      "choice4": "실제로 필요할 때만 페이지를 적재하여 메모리 효율을 높이기 위해",
      "answer": 4,
      "explanation": "Lazy Loading은 불필요한 페이지를 미리 로드하지 않아 메모리 사용을 절약한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 151,
    "fields": {
      "question": "Linux에서 Completely Fair Scheduler(CFS)가 프로세스를 스케줄링할 때 사용하는 핵심 자료구조는?",
      "choice1": "Red-Black Tree",
      "choice2": "Hash Table",
      "choice3": "Array List",
      "choice4": "Queue",
      "answer": 1,
      "explanation": "CFS는 실행 시간을 공정하게 배분하기 위해 Red-Black Tree 기반 구조를 사용한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 152,
    "fields": {
      "question": "NUMA 시스템에서 성능 최적화를 위해 중요한 개념은?",
      "choice1": "모든 CPU가 동일 속도로 동작",
      "choice2": "디스크 캐싱 비활성화",
      "choice3": "페이지 교체율 증가",
      "choice4": "메모리 접근 지역성(Locality)",
      "answer": 4,
      "explanation": "NUMA는 CPU가 가까운 메모리에 더 빠르게 접근한다는 특성을 가지므로 지역성이 핵심이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 153,
    "fields": {
      "question": "운영체제에서 write-back 캐시 정책의 주요 단점은?",
      "choice1": "비정상 종료 시 데이터 유실 가능성",
      "choice2": "캐시 크기가 필요 없다",
      "choice3": "항상 즉시 쓰기 때문에 속도가 느리다",
      "choice4": "디스크 I/O가 늘어난다",
      "answer": 1,
      "explanation": "write-back은 지연 기록 방식이라 장애 발생 시 손실 위험이 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 154,
    "fields": {
      "question": "페이지 교체 알고리즘 중 Working Set 모델의 핵심 목적은?",
      "choice1": "디스크 사용량 감소",
      "choice2": "랜덤 교체를 통한 평균적 성능 향상",
      "choice3": "프로세스의 실제 필요 페이지 집합을 유지",
      "choice4": "가장 오래된 페이지 제거",
      "answer": 3,
      "explanation": "Working Set은 특정 시간 범위에서 실제 참조된 페이지 집합을 유지해 쓰레싱을 방지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 155,
    "fields": {
      "question": "Linux에서 메모리 오버커밋(Overcommit)을 허용하는 이유는?",
      "choice1": "실제 요청보다 적은 페이지를 사용하기 때문",
      "choice2": "프로세스 생성이 불가능하기 때문",
      "choice3": "디스크 스왑 공간이 필요 없기 때문",
      "choice4": "항상 모든 페이지가 물리 메모리에 존재해야 하기 때문",
      "answer": 1,
      "explanation": "실제로 많은 프로그램은 요청한 메모리를 다 사용하지 않으므로 오버커밋으로 효율 향상이 가능하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 156,
    "fields": {
      "question": "I/O 스케줄러 중 Deadline 스케줄러가 사용하는 핵심 전략은?",
      "choice1": "랜덤 I/O 수행",
      "choice2": "프로세스 우선순위만 고려",
      "choice3": "각 요청에 데드라인을 부여해 응답 지연을 줄임",
      "choice4": "가장 가까운 트랙을 우선",
      "answer": 3,
      "explanation": "Deadline 스케줄러는 요청에 데드라인을 설정해 특정 요청이 오래 기다리지 않게 한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 157,
    "fields": {
      "question": "하이퍼바이저(Hypervisor) 타입 1의 주요 장점은?",
      "choice1": "하드웨어 위에서 직접 동작하여 오버헤드가 적다",
      "choice2": "가상머신 간 통신이 불가능하다",
      "choice3": "호스트 OS가 필요하다",
      "choice4": "더 많은 드라이버가 필요하다",
      "answer": 1,
      "explanation": "타입 1은 bare-metal 방식으로 동작해 성능 오버헤드가 적다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 158,
    "fields": {
      "question": "메모리 동기화에서 Memory Barrier의 역할은?",
      "choice1": "캐시를 초기화",
      "choice2": "인터럽트를 비활성화",
      "choice3": "명령 재배치를 제한해 순서를 보장",
      "choice4": "프로세스 우선순위를 증가",
      "answer": 3,
      "explanation": "메모리 배리어는 컴파일러와 CPU의 재정렬을 제한하여 순서 보장을 강제한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 159,
    "fields": {
      "question": "Linux의 OOM Killer의 선택 기준과 가장 관련 깊은 값은?",
      "choice1": "file size",
      "choice2": "thread count",
      "choice3": "network usage",
      "choice4": "oom_score",
      "answer": 4,
      "explanation": "Linux는 oom_score를 기준으로 종료할 프로세스를 선택한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 160,
    "fields": {
      "question": "Copy-on-Write가 fork 이후 exec이 호출될 때 효율적인 이유는?",
      "choice1": "커널 메모리만 사용한다",
      "choice2": "스택만 복사된다",
      "choice3": "모든 페이지가 미리 복사된다",
      "choice4": "대부분 즉시 새로운 프로그램으로 교체되므로 페이지 복사가 거의 일어나지 않는다",
      "answer": 4,
      "explanation": "exec 호출 시 기존 프로세스 메모리가 대체되므로 fork 후 실질 페이지 복사가 거의 필요 없다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 161,
    "fields": {
      "question": "Modern OS의 파일 시스템에서 B-tree 기반 구조를 사용하는 가장 큰 이유는?",
      "choice1": "대규모 디렉터리에서도 탐색 효율이 높기 때문",
      "choice2": "디스크 용량을 줄이기 위해",
      "choice3": "모든 파일을 정적으로 배치하기 위해",
      "choice4": "로그 기능을 제거하기 위해",
      "answer": 1,
      "explanation": "B-tree는 대규모 파일 시스템에서도 빠른 검색을 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 162,
    "fields": {
      "question": "SMP 환경에서 Lock Contention을 줄이기 위해 사용하는 기법은?",
      "choice1": "Single Locking",
      "choice2": "Static Queueing",
      "choice3": "Global Lock",
      "choice4": "Fine-grained Locking",
      "answer": 4,
      "explanation": "미세 잠금(Fine-grained locking)은 병렬성을 높여 경합을 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 163,
    "fields": {
      "question": "리눅스 Completely Fair Scheduler에서 vruntime이 커지는 원인은?",
      "choice1": "커널 모드 시간이 많기 때문",
      "choice2": "CPU를 상대적으로 많이 사용했기 때문",
      "choice3": "프로세스가 Blocked 상태이기 때문",
      "choice4": "I/O 바운드이기 때문",
      "answer": 2,
      "explanation": "CFS는 CPU를 더 사용한 프로세스의 vruntime을 증가시켜 공정성을 유지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 164,
    "fields": {
      "question": "운영체제의 Lock-Free 알고리즘에서 주로 사용하는 원자적 연산은?",
      "choice1": "Division",
      "choice2": "CAS(Compare-And-Swap)",
      "choice3": "Shift",
      "choice4": "Modulo",
      "answer": 2,
      "explanation": "CAS는 Lock-Free 자료구조 구현에 핵심이 되는 원자적 연산이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 165,
    "fields": {
      "question": "페이지 교체 알고리즘 중 Second-Chance 알고리즘은 어떤 알고리즘의 변형인가?",
      "choice1": "Optimal",
      "choice2": "FIFO",
      "choice3": "Clock",
      "choice4": "LRU",
      "answer": 2,
      "explanation": "Second-Chance는 FIFO를 보완하기 위해 참조 비트를 확인하는 방식이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 166,
    "fields": {
      "question": "Zoned Storage(HDD/SSD)에서 Sequential Write가 중요한 이유는?",
      "choice1": "읽기 속도가 향상되기 때문",
      "choice2": "특정 구역은 순차 쓰기만 가능하도록 설계되어 있기 때문",
      "choice3": "캐시가 필요 없기 때문",
      "choice4": "랜덤 접근이 더 빠르기 때문",
      "answer": 2,
      "explanation": "ZNS 같은 장치는 Sequential Write를 요구하며 Random Write는 비효율적이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 167,
    "fields": {
      "question": "운영체제에서 kernel preemption을 허용하는 것의 장점은?",
      "choice1": "문맥 교환이 사라진다",
      "choice2": "커널이 더 단순해진다",
      "choice3": "I/O 성능이 감소한다",
      "choice4": "응답성이 향상된다",
      "answer": 4,
      "explanation": "커널 선점은 대화형 시스템의 응답성을 크게 향상시킨다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 168,
    "fields": {
      "question": "리눅스에서 Huge Pages를 사용하는 이유는?",
      "choice1": "스와핑 증가",
      "choice2": "문맥 전환 증가",
      "choice3": "TLB 미스 감소",
      "choice4": "캐시 무효화 수행",
      "answer": 3,
      "explanation": "큰 페이지는 TLB 엔트리 수요를 줄여 TLB miss를 줄일 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 169,
    "fields": {
      "question": "운영체제에서 Priority Inversion 문제를 해결하는 대표적인 기법은?",
      "choice1": "Non-preemptive Scheduling",
      "choice2": "Busy Waiting",
      "choice3": "Spin Lock",
      "choice4": "Priority Inheritance",
      "answer": 4,
      "explanation": "우선순위 상속은 낮은 우선순위가 높은 우선순위를 막는 문제를 해결한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 170,
    "fields": {
      "question": "페이지 교체에서 Optimal 알고리즘이 실제 운영체제에서 사용되지 않는 이유는?",
      "choice1": "미래의 참조를 알 수 없기 때문",
      "choice2": "캐시 메모리가 없기 때문",
      "choice3": "계산량이 너무 적기 때문",
      "choice4": "프로세스 수가 고정되어 있기 때문",
      "answer": 1,
      "explanation": "OPT는 미래 참조 정보를 필요로 하므로 이론적 기준일 뿐 실제 적용 불가하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 171,
    "fields": {
      "question": "Direct I/O가 Buffered I/O와 다른 점은?",
      "choice1": "페이지 캐시를 우회한다",
      "choice2": "항상 더 빠르다",
      "choice3": "커널이 I/O를 처리하지 않는다",
      "choice4": "I/O가 비동기로만 처리된다",
      "answer": 1,
      "explanation": "Direct I/O는 캐시를 거치지 않고 디스크와 직접 I/O를 수행한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 172,
    "fields": {
      "question": "운영체제에서 Spin Lock을 사용하면 좋은 상황은?",
      "choice1": "영구적 mutual exclusion이 필요할 때",
      "choice2": "I/O 대기 시간이 길 때",
      "choice3": "잠금 보유 시간이 매우 짧을 때",
      "choice4": "CPU가 하나일 때",
      "answer": 3,
      "explanation": "Spin Lock은 짧은 임계 구역에서 오버헤드를 줄이는 데 유리하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 173,
    "fields": {
      "question": "Slab Allocator의 핵심 목적은?",
      "choice1": "스레드 스케줄링 최적화",
      "choice2": "디스크 블록을 압축",
      "choice3": "동일 크기 객체를 빠르게 할당/해제",
      "choice4": "캐시 미스 감소",
      "answer": 3,
      "explanation": "Slab Allocator는 객체 기반 메모리 관리를 통해 빠른 메모리 할당을 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 174,
    "fields": {
      "question": "파일 시스템의 Write Amplification을 줄이기 위한 대표적 기술은?",
      "choice1": "Log-structured File System",
      "choice2": "Double Write",
      "choice3": "Explicit Fragmentation",
      "choice4": "Fixed Allocation",
      "answer": 1,
      "explanation": "Log-structured FS는 순차 기록을 통해 write amplification을 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 175,
    "fields": {
      "question": "커널에서 SoftIRQ와 HardIRQ를 분리하는 이유는?",
      "choice1": "스레드 수를 줄이기 위해",
      "choice2": "시간이 오래 걸리는 작업을 나중에 처리하도록 하기 위해",
      "choice3": "모든 인터럽트를 즉시 처리하기 위해",
      "choice4": "커널 공간을 줄이기 위해",
      "answer": 2,
      "explanation": "HardIRQ는 즉시 처리, SoftIRQ는 지연 처리하여 시스템 부하를 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 176,
    "fields": {
      "question": "Multi-version Concurrency Control(MVCC)의 핵심 아이디어는?",
      "choice1": "모든 읽기/쓰기에 락 사용",
      "choice2": "페이지 교체 최소화",
      "choice3": "데이터의 여러 버전을 유지해 읽기 작업을 차단하지 않음",
      "choice4": "단일 버전만 유지",
      "answer": 3,
      "explanation": "MVCC는 동시성 향상을 위해 데이터 버전을 여러 개 유지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 177,
    "fields": {
      "question": "운영체제에서 Pre-fetching을 사용하는 목적은?",
      "choice1": "교착 상태를 제거",
      "choice2": "TLB를 무효화",
      "choice3": "캐시를 제거",
      "choice4": "미리 필요한 데이터를 로드해 페이지 폴트를 줄임",
      "answer": 4,
      "explanation": "Pre-fetching은 예상 접근 페이지를 미리 로드해 성능을 향상시킨다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 178,
    "fields": {
      "question": "Kernel Thread와 User Thread의 가장 큰 차이는?",
      "choice1": "스택 크기만 다르다",
      "choice2": "스케줄링 주체가 커널인지 사용자 레벨인지",
      "choice3": "항상 1:1 매핑된다",
      "choice4": "메모리를 공유하지 않는다",
      "answer": 2,
      "explanation": "Kernel Thread는 커널이 스케줄링하며 User Thread는 라이브러리가 스케줄링한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 179,
    "fields": {
      "question": "운영체제에서 Lazy TLB Shootdown을 사용하는 목적은?",
      "choice1": "페이지 크기를 증가시키기 위해",
      "choice2": "모든 코어를 즉시 동기화",
      "choice3": "TLB flush 비용 최소화",
      "choice4": "TLB를 전적으로 제거하기 위해",
      "answer": 3,
      "explanation": "Lazy Shootdown은 코어 간 동기화 오버헤드를 줄여 성능을 최적화한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 180,
    "fields": {
      "question": "Speculative Execution이 운영체제와 시스템에서 문제가 될 수 있는 이유는?",
      "choice1": "스케줄러가 작동하지 않는다",
      "choice2": "프로세스 생성이 불가능해진다",
      "choice3": "압축된 실행 경로가 캐시를 오염시켜 보안 취약점(Spectre) 발생 가능",
      "choice4": "항상 성능을 저하시킨다",
      "answer": 3,
      "explanation": "추측 실행은 잘못된 경로의 캐시 정보가 남아 보안 취약점을 유발할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 2,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 181,
    "fields": {
      "question": "데이터베이스에서 중복 데이터를 최소화하기 위한 기본 개념은?",
      "choice1": "트랜잭션",
      "choice2": "정규화",
      "choice3": "샤딩",
      "choice4": "인덱싱",
      "answer": 2,
      "explanation": "정규화는 데이터 중복을 줄이고 일관성을 유지하기 위한 구조화 과정이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 182,
    "fields": {
      "question": "SQL에서 데이터를 조회할 때 사용하는 기본 명령어는?",
      "choice1": "SELECT",
      "choice2": "INSERT",
      "choice3": "UPDATE",
      "choice4": "DELETE",
      "answer": 1,
      "explanation": "SELECT는 데이터베이스에서 원하는 데이터를 조회할 때 사용된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 183,
    "fields": {
      "question": "기본 키(Primary Key)의 핵심 속성은?",
      "choice1": "외래키를 대신한다",
      "choice2": "여러 개 존재할 수 있다",
      "choice3": "중복이 불가능하다",
      "choice4": "NULL을 허용한다",
      "answer": 3,
      "explanation": "기본 키는 각 행을 유일하게 식별할 수 있어야 하므로 중복될 수 없다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 184,
    "fields": {
      "question": "하나의 테이블에서 다른 테이블을 참조하기 위해 사용하는 키는?",
      "choice1": "대체 키",
      "choice2": "기본 키",
      "choice3": "후보 키",
      "choice4": "외래키(Foreign Key)",
      "answer": 4,
      "explanation": "외래키는 다른 테이블의 기본 키를 참조하여 관계를 맺는다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 185,
    "fields": {
      "question": "SQL에서 전체 행을 삭제하되 테이블 구조는 유지하는 명령은?",
      "choice1": "DELETE ALL",
      "choice2": "REMOVE",
      "choice3": "DROP",
      "choice4": "TRUNCATE",
      "answer": 4,
      "explanation": "TRUNCATE는 데이터를 모두 제거하지만 테이블은 그대로 남는다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 186,
    "fields": {
      "question": "관계형 데이터베이스에서 데이터를 표 형태로 저장하는 구조는?",
      "choice1": "그래프",
      "choice2": "테이블(Table)",
      "choice3": "큐",
      "choice4": "문서(Document)",
      "answer": 2,
      "explanation": "관계형 DB는 행과 열로 구성된 테이블에 데이터를 저장한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 187,
    "fields": {
      "question": "SQL에서 조건을 지정할 때 사용하는 키워드는?",
      "choice1": "ORDER",
      "choice2": "WHERE",
      "choice3": "LIKE",
      "choice4": "GROUP",
      "answer": 2,
      "explanation": "WHERE 절은 조회 또는 수정 시 조건을 지정할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 188,
    "fields": {
      "question": "중복 없는 유일한 값만 조회하려면 어떤 키워드를 사용해야 하는가?",
      "choice1": "UNIQUE",
      "choice2": "ONLY",
      "choice3": "SEPARATE",
      "choice4": "DISTINCT",
      "answer": 4,
      "explanation": "DISTINCT는 중복을 제거하고 유일한 값만 반환한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 189,
    "fields": {
      "question": "ORDER BY에서 기본 정렬 방식은?",
      "choice1": "랜덤",
      "choice2": "오름차순",
      "choice3": "선입선출",
      "choice4": "내림차순",
      "answer": 2,
      "explanation": "ORDER BY는 기본적으로 ASC(오름차순) 정렬을 수행한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 190,
    "fields": {
      "question": "INSERT 문으로 여러 건의 데이터를 한 번에 삽입할 수 있는 방식은?",
      "choice1": "JOIN 사용",
      "choice2": "TRUNCATE 후 삽입",
      "choice3": "한 번에 하나만 가능",
      "choice4": "VALUES 절에 여러 행을 나열",
      "answer": 4,
      "explanation": "INSERT INTO ... VALUES (...), (...), (...) 형태로 여러 행 삽입이 가능하다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 191,
    "fields": {
      "question": "트랜잭션의 원자성을 의미하는 것은?",
      "choice1": "모든 작업이 전부 수행되거나 전혀 수행되지 않아야 한다",
      "choice2": "데이터 크기가 줄어든다",
      "choice3": "항상 동시에 실행된다",
      "choice4": "속도가 빨라진다",
      "answer": 1,
      "explanation": "원자성은 트랜잭션의 부분이 아닌 전체가 하나의 단위로 처리되어야 함을 의미한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 192,
    "fields": {
      "question": "데이터베이스에서 인덱스를 사용하면 주로 향상되는 것은?",
      "choice1": "저장 공간",
      "choice2": "트랜잭션 개수",
      "choice3": "조회 속도",
      "choice4": "정규화 정도",
      "answer": 3,
      "explanation": "인덱스는 검색 속도를 대폭 향상시키는 자료구조이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 193,
    "fields": {
      "question": "JOIN 중 두 테이블에서 조건에 맞는 행만 반환하는 것은?",
      "choice1": "FULL JOIN",
      "choice2": "RIGHT JOIN",
      "choice3": "LEFT JOIN",
      "choice4": "INNER JOIN",
      "answer": 4,
      "explanation": "INNER JOIN은 두 테이블 모두 일치하는 행만 출력한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 194,
    "fields": {
      "question": "COUNT() 함수의 기능은?",
      "choice1": "전체 행 수를 반환",
      "choice2": "문자열 길이 반환",
      "choice3": "NULL의 개수만 반환",
      "choice4": "숫자 합을 계산",
      "answer": 1,
      "explanation": "COUNT()는 조건과 관계없이 전체 행 개수를 세는 함수이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 195,
    "fields": {
      "question": "데이터 무결성 중 ‘값이 존재해야 하는 규칙’을 의미하는 것은?",
      "choice1": "개체 무결성",
      "choice2": "참조 무결성",
      "choice3": "키 무결성",
      "choice4": "도메인 무결성",
      "answer": 4,
      "explanation": "도메인 무결성은 각 속성이 유효한 값 범위를 가져야 함을 의미한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 196,
    "fields": {
      "question": "SQL에서 문자열 검색에 사용되는 패턴 연산자는?",
      "choice1": "IN",
      "choice2": "LIKE",
      "choice3": "BETWEEN",
      "choice4": "MATCH",
      "answer": 2,
      "explanation": "LIKE는 %, _ 와 함께 패턴 검색을 수행한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 197,
    "fields": {
      "question": "GROUP BY 절을 사용할 때 집계 함수와 함께 사용하는 조건문은?",
      "choice1": "CHECK",
      "choice2": "HAVING",
      "choice3": "LIMIT",
      "choice4": "WHERE",
      "answer": 2,
      "explanation": "HAVING은 그룹화된 결과에 조건을 적용하는 키워드이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 198,
    "fields": {
      "question": "RDBMS의 대표적인 예는?",
      "choice1": "Redis",
      "choice2": "MongoDB",
      "choice3": "MySQL",
      "choice4": "ElasticSearch",
      "answer": 3,
      "explanation": "MySQL은 대표적인 관계형 데이터베이스 관리 시스템이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 199,
    "fields": {
      "question": "테이블의 구조를 변경하는 SQL 명령은?",
      "choice1": "ALTER",
      "choice2": "TRIM",
      "choice3": "UPDATE",
      "choice4": "MODIFY",
      "answer": 1,
      "explanation": "ALTER TABLE은 테이블 구조 변경에 사용된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 200,
    "fields": {
      "question": "UNIQUE 제약 조건의 특징은?",
      "choice1": "NULL을 허용하지 않는다",
      "choice2": "외래키를 자동 생성한다",
      "choice3": "기본 키와 동일하다",
      "choice4": "중복을 허용하지 않는다",
      "answer": 4,
      "explanation": "UNIQUE는 중복을 허용하지 않지만 NULL은 허용할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 201,
    "fields": {
      "question": "데이터베이스의 트랜잭션을 취소하는 명령은?",
      "choice1": "RESET",
      "choice2": "UNDO",
      "choice3": "ROLLBACK",
      "choice4": "COMMIT",
      "answer": 3,
      "explanation": "ROLLBACK은 트랜잭션을 취소하고 변경된 내용을 되돌린다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 202,
    "fields": {
      "question": "SQL에서 중복된 행을 제거하기 위해 사용하는 키워드는?",
      "choice1": "REDUCE",
      "choice2": "ONE",
      "choice3": "DISTINCT",
      "choice4": "FILTER",
      "answer": 3,
      "explanation": "DISTINCT는 SELECT 결과의 중복값을 제거한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 203,
    "fields": {
      "question": "외래키가 참조하는 기본 키가 삭제될 때 연쇄적으로 삭제되도록 지정하는 옵션은?",
      "choice1": "ON DELETE RESET",
      "choice2": "ON DELETE BLOCK",
      "choice3": "ON DELETE HOLD",
      "choice4": "ON DELETE CASCADE",
      "answer": 4,
      "explanation": "CASCADE는 참조 무결성을 유지하기 위해 연쇄 삭제를 수행한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 204,
    "fields": {
      "question": "데이터베이스의 스키마(Schema)가 의미하는 것은?",
      "choice1": "데이터베이스 구조 정의",
      "choice2": "네트워크 연결 정보",
      "choice3": "데이터의 실제 값",
      "choice4": "인덱스만 모아놓은 것",
      "answer": 1,
      "explanation": "스키마는 DB의 구조, 제약조건 등을 정의한 논리적 설계이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 205,
    "fields": {
      "question": "SQL에서 테이블을 삭제하는 명령은?",
      "choice1": "CUT",
      "choice2": "CLOSE",
      "choice3": "DROP",
      "choice4": "REMOVE",
      "answer": 3,
      "explanation": "DROP TABLE은 테이블 구조와 데이터를 완전히 제거한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 206,
    "fields": {
      "question": "비관적 락(Pessimistic Lock)의 기본 개념은?",
      "choice1": "트랜잭션을 나누지 않는다",
      "choice2": "항상 읽기만 가능",
      "choice3": "충돌이 일어난다고 보고 먼저 잠근다",
      "choice4": "충돌이 없다고 가정하고 작업",
      "answer": 3,
      "explanation": "비관적 락은 잠재적 충돌을 방지하기 위해 먼저 자원을 잠근다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 207,
    "fields": {
      "question": "인덱스 생성 시 과도한 인덱스 사용의 단점은?",
      "choice1": "메모리 사용 감소",
      "choice2": "JOIN 불가",
      "choice3": "쓰기 속도 저하",
      "choice4": "조회 속도 저하",
      "answer": 3,
      "explanation": "인덱스는 쓰기 작업 시 매번 갱신되어 삽입·수정 속도를 느리게 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 208,
    "fields": {
      "question": "SQL에서 부분 문자열을 찾기 위해 LIKE와 함께 사용하는 와일드카드 %의 의미는?",
      "choice1": "숫자만",
      "choice2": "공백만",
      "choice3": "단일 문자",
      "choice4": "0개 이상의 임의 문자",
      "answer": 4,
      "explanation": "%는 0개 이상 모든 문자열을 의미한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 209,
    "fields": {
      "question": "데이터의 일관성을 유지하기 위한 트랜잭션 ACID 중 C는 무엇을 의미하는가?",
      "choice1": "Connection",
      "choice2": "Control",
      "choice3": "Copy",
      "choice4": "Consistency",
      "answer": 4,
      "explanation": "Consistency는 트랜잭션 전후 데이터의 일관성을 유지해야 함을 의미한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 210,
    "fields": {
      "question": "SQL에서 테이블을 새로 생성할 때 사용하는 명령은?",
      "choice1": "NEW TABLE",
      "choice2": "BUILD TABLE",
      "choice3": "GENERATE TABLE",
      "choice4": "CREATE TABLE",
      "answer": 4,
      "explanation": "CREATE TABLE 명령으로 새로운 테이블을 정의할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 211,
    "fields": {
      "question": "정규화에서 이상 현상(Anomaly)을 방지하기 위한 기본 목적은?",
      "choice1": "트랜잭션을 줄이기 위해",
      "choice2": "인덱스를 자동 생성하기 위해",
      "choice3": "데이터 구조를 작게 나누어 중복을 제거하기 위해",
      "choice4": "조회 속도를 무조건 빠르게 하기 위해",
      "answer": 3,
      "explanation": "정규화는 삽입·삭제·갱신 이상을 방지하기 위해 중복을 제거하는 과정이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 212,
    "fields": {
      "question": "3정규형(3NF)의 핵심 조건은?",
      "choice1": "이행적 종속이 없어야 한다",
      "choice2": "모든 속성이 단일값이어야 한다",
      "choice3": "모든 결정자가 후보키여야 한다",
      "choice4": "반정규화를 수행해야 한다",
      "answer": 1,
      "explanation": "3NF는 기본적으로 이행적 종속이 제거된 상태를 의미한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 213,
    "fields": {
      "question": "데이터베이스에서 트랜잭션 격리 수준 중 팬텀 리드(Phantom Read)를 방지하는 수준은?",
      "choice1": "READ COMMITTED",
      "choice2": "SERIALIZABLE",
      "choice3": "REPEATABLE READ",
      "choice4": "READ UNCOMMITTED",
      "answer": 2,
      "explanation": "SERIALIZABLE은 가장 높은 격리 수준으로 팬텀 리드를 방지한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 214,
    "fields": {
      "question": "인덱스가 SELECT 성능을 향상시키는 주요 이유는?",
      "choice1": "쓰기 연산이 없어지기 때문에",
      "choice2": "모든 데이터를 캐시에 저장하기 때문에",
      "choice3": "모든 테이블을 자동 분리하기 때문에",
      "choice4": "정렬된 구조로 탐색 비용을 줄이기 때문에",
      "answer": 4,
      "explanation": "인덱스는 정렬된 B-Tree 구조 등을 통해 탐색 속도를 크게 높인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 215,
    "fields": {
      "question": "조인(Join) 방식 중 해시 기반으로 수행되는 조인은?",
      "choice1": "Merge Join",
      "choice2": "Tree Join",
      "choice3": "Nested Loop Join",
      "choice4": "Hash Join",
      "answer": 4,
      "explanation": "Hash Join은 해시 테이블을 이용해 빠르게 매칭하는 조인 방식이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 216,
    "fields": {
      "question": "WHERE 절에서 인덱스가 잘 적용되기 위해서는 어떤 조건이 중요한가?",
      "choice1": "ORDER BY가 있어야 한다",
      "choice2": "NULL 값이 많아야 한다",
      "choice3": "데이터가 무작위여야 한다",
      "choice4": "선행 컬럼 선택도가 높아야 한다",
      "answer": 4,
      "explanation": "인덱스는 선택도가 높은(결과 범위가 작은) 조건에서 효과적이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 217,
    "fields": {
      "question": "클러스터드 인덱스(Clustered Index)의 특징은?",
      "choice1": "조회 성능이 비클러스터드보다 떨어짐",
      "choice2": "데이터가 무작위 블록에 저장됨",
      "choice3": "테이블 자체가 인덱스 구조로 저장된다",
      "choice4": "항상 여러 개 생성 가능",
      "answer": 3,
      "explanation": "클러스터드 인덱스는 테이블 자체가 정렬된 인덱스 구조로 유지된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 218,
    "fields": {
      "question": "RDBMS에서 Join이 많이 발생하는 이유는?",
      "choice1": "정규화된 구조 때문에 데이터가 여러 테이블로 나누어지기 때문",
      "choice2": "인덱스를 생성하지 않기 때문에",
      "choice3": "해시 테이블 기반이기 때문",
      "choice4": "트랜잭션을 줄이기 위해",
      "answer": 1,
      "explanation": "정규화는 중복을 줄이는 대신 테이블 분할이 증가하여 Join이 자주 필요하다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 219,
    "fields": {
      "question": "트랜잭션에서 격리성(Isolation)의 목적은?",
      "choice1": "정규화를 단순화하기 위해",
      "choice2": "인덱스를 자동 생성하기 위해",
      "choice3": "동시성 문제를 방지하기 위해",
      "choice4": "저장 공간을 줄이기 위해",
      "answer": 3,
      "explanation": "Isolation은 서로 다른 트랜잭션이 충돌하지 않도록 격리하는 기능이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 220,
    "fields": {
      "question": "ER 모델에서 약한 엔티티(Weak Entity)의 특징은?",
      "choice1": "관계를 가질 수 없다",
      "choice2": "외래키를 생성할 수 없다",
      "choice3": "자체 식별자가 없고 다른 엔티티에 의존한다",
      "choice4": "항상 기본 키를 가진다",
      "answer": 3,
      "explanation": "약한 엔티티는 스스로 식별할 수 없어 다른 엔티티의 PK를 함께 사용한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 221,
    "fields": {
      "question": "중복 인덱스를 남발하면 생기는 대표적 문제는?",
      "choice1": "정렬 불가능",
      "choice2": "쓰기 성능 저하",
      "choice3": "트랜잭션 격리 수준 저하",
      "choice4": "읽기 성능 저하",
      "answer": 2,
      "explanation": "인덱스는 쓰기 작업 시 함께 수정되어 쓰기 성능을 떨어뜨린다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 222,
    "fields": {
      "question": "UNION과 UNION ALL의 차이는?",
      "choice1": "UNION은 중복 제거, UNION ALL은 중복 허용",
      "choice2": "UNION은 오직 숫자만 처리함",
      "choice3": "UNION은 빠르고 UNION ALL은 느리다",
      "choice4": "UNION ALL은 DISTINCT 포함",
      "answer": 1,
      "explanation": "UNION은 DISTINCT가 포함되므로 중복이 제거된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 223,
    "fields": {
      "question": "NoSQL의 특징 중 하나는?",
      "choice1": "스키마가 유연하다",
      "choice2": "ACID만 지원",
      "choice3": "반드시 관계형 모델을 사용",
      "choice4": "JOIN 필수",
      "answer": 1,
      "explanation": "NoSQL은 비정형 데이터를 유연하게 저장할 수 있도록 스키마 유연성을 제공한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 224,
    "fields": {
      "question": "Foreign Key 제약 조건을 비활성화하면 어떤 위험이 증가하는가?",
      "choice1": "조회 속도 감소",
      "choice2": "인덱스 자동 삭제",
      "choice3": "정규화 수준 감소",
      "choice4": "데이터 무결성 훼손",
      "answer": 4,
      "explanation": "FK 제약을 사용하지 않으면 참조 무결성이 깨질 위험이 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 225,
    "fields": {
      "question": "GROUP BY를 사용할 때 SELECT 절에 포함될 수 있는 항목은?",
      "choice1": "인덱스 컬럼만 가능",
      "choice2": "집계 함수 또는 그룹화된 컬럼",
      "choice3": "아무 컬럼이나 가능",
      "choice4": "WHERE 조건만 가능",
      "answer": 2,
      "explanation": "GROUP BY는 집계 함수 또는 그룹 기준 컬럼만 SELECT에 포함할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 226,
    "fields": {
      "question": "트랜잭션 격리 수준 READ COMMITTED에서 방지되는 문제는?",
      "choice1": "모든 동시성 오류",
      "choice2": "팬텀 리드",
      "choice3": "반복 불가능 읽기",
      "choice4": "더티 리드(Dirty Read)",
      "answer": 4,
      "explanation": "READ COMMITTED는 커밋되지 않은 데이터를 읽는 Dirty Read를 방지한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 227,
    "fields": {
      "question": "쿼리 옵티마이저가 사용하는 실행 계획 선택 기준은?",
      "choice1": "사용자 ID",
      "choice2": "테이블 생성 날짜",
      "choice3": "컬럼 이름 길이",
      "choice4": "비용 기반(Cost-based)",
      "answer": 4,
      "explanation": "대부분의 현대 DB는 Cost-Based Optimizer(CBO)를 사용한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 228,
    "fields": {
      "question": "데이터베이스에서 View 사용의 장점은?",
      "choice1": "보안 강화 및 복잡한 쿼리 단순화",
      "choice2": "트랜잭션 감소",
      "choice3": "테이블 자동 생성",
      "choice4": "조회 성능 항상 향상",
      "answer": 1,
      "explanation": "View는 특정 컬럼만 노출하도록 하여 보안을 강화하고 복잡한 쿼리를 단순하게 만든다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 229,
    "fields": {
      "question": "DBMS에서 Lock Escalation의 목적은?",
      "choice1": "잠금 수를 줄여 성능을 향상시키기 위해",
      "choice2": "모든 테이블을 잠그기 위해",
      "choice3": "인덱스를 줄이기 위해",
      "choice4": "쿼리 오류를 감추기 위해",
      "answer": 1,
      "explanation": "너무 많은 Row Lock이 있을 경우 Block Lock으로 승격하여 오버헤드를 줄인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 230,
    "fields": {
      "question": "파티셔닝(partitioning)의 장점은?",
      "choice1": "정규화 수준을 자동 향상",
      "choice2": "대용량 테이블을 물리적으로 분리해 성능을 높인다",
      "choice3": "인덱스를 제거",
      "choice4": "트랜잭션을 단일로 합침",
      "answer": 2,
      "explanation": "파티셔닝은 테이블을 여러 단위로 나누어 관리 효율과 성능을 향상한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 231,
    "fields": {
      "question": "Non-clustered Index의 특징은?",
      "choice1": "하나만 생성 가능",
      "choice2": "테이블 크기를 줄임",
      "choice3": "데이터가 인덱스 순으로 저장됨",
      "choice4": "데이터와 별도로 인덱스 구조가 존재",
      "answer": 4,
      "explanation": "비클러스터드 인덱스는 테이블과 별도로 인덱스가 구성된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 232,
    "fields": {
      "question": "실행 계획에서 Nested Loop Join이 적합한 경우는?",
      "choice1": "두 테이블 모두 대용량",
      "choice2": "한쪽 테이블이 매우 작은 경우",
      "choice3": "정렬된 컬럼이 많을 때",
      "choice4": "해시 테이블이 필요할 때",
      "answer": 2,
      "explanation": "작은 테이블 + 인덱스가 있는 경우 Nested Loop Join이 효율적이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 233,
    "fields": {
      "question": "데이터 모델링에서 카디널리티(Cardinality)의 의미는?",
      "choice1": "트랜잭션 개수",
      "choice2": "제약조건 수",
      "choice3": "관계의 개수",
      "choice4": "속성명",
      "answer": 3,
      "explanation": "Cardinality는 테이블 간 관계의 수를 나타내며 1:1, 1:N 등을 의미한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 234,
    "fields": {
      "question": "데이터베이스 백업 방식 중 전체(full) 백업에 비해 증분(incremental) 백업의 장점은?",
      "choice1": "모든 데이터를 다시 읽는다",
      "choice2": "항상 더 안전하다",
      "choice3": "복원이 단순하다",
      "choice4": "백업 속도가 빠르다",
      "answer": 4,
      "explanation": "증분 백업은 변경된 데이터만 저장하므로 빠르고 저장공간도 적게 든다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 235,
    "fields": {
      "question": "인덱스 스캔 중 Range Scan이 발생하려면 어떤 조건이 필요한가?",
      "choice1": "조인 조건이 반드시 존재",
      "choice2": "HAVING 절만 사용",
      "choice3": "조건이 정렬된 인덱스 범위에 해당",
      "choice4": "DISTINCT가 필수",
      "answer": 3,
      "explanation": "정렬된 인덱스에서 범위를 검색할 때 Range Scan이 일어난다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 236,
    "fields": {
      "question": "DBMS의 버퍼 매니저가 사용하는 페이지 교체 정책 중 대표적인 것은?",
      "choice1": "LFU",
      "choice2": "FIFO",
      "choice3": "Random",
      "choice4": "LRU",
      "answer": 4,
      "explanation": "많은 DBMS가 LRU 기반 알고리즘을 버퍼 교체정책으로 사용한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 237,
    "fields": {
      "question": "저장 프로시저(Stored Procedure)의 장점은?",
      "choice1": "트랜잭션이 필요 없다",
      "choice2": "서버에서 실행되어 네트워크 트래픽을 줄인다",
      "choice3": "정규화를 제거",
      "choice4": "항상 조회 성능을 향상",
      "answer": 2,
      "explanation": "저장 프로시저는 로직을 서버에서 직접 실행해 네트워크 비용을 줄인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 238,
    "fields": {
      "question": "MVCC가 READ COMMITTED보다 유리한 이유는?",
      "choice1": "항상 더 빠르기 때문이다",
      "choice2": "데이터 저장량이 줄기 때문이다",
      "choice3": "JOIN이 불필요해지기 때문이다",
      "choice4": "락 충돌 없이 읽기가 가능하기 때문이다",
      "answer": 4,
      "explanation": "MVCC는 읽기 시 락을 걸지 않아 동시성이 높다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 239,
    "fields": {
      "question": "Explain Plan에서 Cost가 의미하는 것은?",
      "choice1": "트랜잭션 길이",
      "choice2": "테이블 수",
      "choice3": "인덱스 크기",
      "choice4": "쿼리를 수행하는 데 필요한 예상 연산 비용",
      "answer": 4,
      "explanation": "Cost는 옵티마이저가 계산한 실행 비용으로 최적 경로 선택의 기준이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 240,
    "fields": {
      "question": "데이터베이스에서 샤딩(Sharding)의 주요 목적은?",
      "choice1": "정규화를 자동 수행",
      "choice2": "수평 분할로 데이터 저장량과 부하를 분산하기 위해",
      "choice3": "트랜잭션을 단일로 합치기",
      "choice4": "인덱스 수를 줄이기",
      "answer": 2,
      "explanation": "샤딩은 데이터를 여러 서버로 분산해 성능과 확장성을 확보하는 기술이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 241,
    "fields": {
      "question": "B-Tree 대신 B+Tree가 인덱스 구조로 더 적합한 이유는?",
      "choice1": "루트 노드가 항상 작기 때문이다",
      "choice2": "데이터를 압축 저장하기 때문이다",
      "choice3": "리프 노드에만 데이터가 저장되어 범위 검색이 더 효율적이다",
      "choice4": "모든 노드가 동일 크기이기 때문이다",
      "answer": 3,
      "explanation": "B+Tree는 리프 노드만 데이터를 가지므로 순차 접근과 범위 검색 속도가 매우 빠르다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 242,
    "fields": {
      "question": "Write-Ahead Logging(WAL)의 핵심 원리는?",
      "choice1": "데이터는 항상 즉시 디스크에 기록한다",
      "choice2": "로그를 마지막에 기록한다",
      "choice3": "데이터 변경을 디스크에 쓰기 전에 로그에 먼저 기록한다",
      "choice4": "트랜잭션을 병렬 실행하지 않는다",
      "answer": 3,
      "explanation": "WAL은 장애 발생 시 복구를 위해 변경 로그를 먼저 기록하는 방식을 말한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 243,
    "fields": {
      "question": "Repeatable Read 격리 수준에서도 발생할 수 있는 문제는?",
      "choice1": "트랜잭션 손실",
      "choice2": "팬텀 리드",
      "choice3": "읽기 스큐(Read Skew)",
      "choice4": "더티 리드",
      "answer": 2,
      "explanation": "Repeatable Read는 동일 행 조회는 보장하지만 새로운 행 삽입으로 인한 팬텀 리드는 방지하지 못한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 244,
    "fields": {
      "question": "Optimistic Lock의 대표적 구현 기법은?",
      "choice1": "페이지 강제 Flush",
      "choice2": "버전 번호 비교",
      "choice3": "행 전체 잠금",
      "choice4": "뮤텍스 사용",
      "answer": 2,
      "explanation": "낙관적 락은 충돌이 거의 없다고 보고 버전 번호를 비교하여 충돌을 감지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 245,
    "fields": {
      "question": "MVCC에서 Snapshot Isolation이 가지는 주요 단점은?",
      "choice1": "Write Skew가 발생할 수 있다",
      "choice2": "Dirty Read가 발생한다",
      "choice3": "인덱스가 항상 무효화된다",
      "choice4": "Repeatable Read보다 약하다",
      "answer": 1,
      "explanation": "Snapshot Isolation은 부분적으로 직렬화되지 않아 Write Skew 문제가 발생할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 246,
    "fields": {
      "question": "분산 DB에서 Two-Phase Commit(2PC)의 가장 큰 단점은?",
      "choice1": "항상 더 빠르다",
      "choice2": "네트워크가 불필요해진다",
      "choice3": "트랜잭션이 필요 없다",
      "choice4": "Coordinator 장애 시 장기적인 블로킹이 발생",
      "answer": 4,
      "explanation": "2PC는 Coordinator가 장애나면 관련 트랜잭션이 오래 블록될 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 247,
    "fields": {
      "question": "PostgreSQL의 Autovacuum이 수행하는 주요 기능은?",
      "choice1": "쿼리 캐시 제거",
      "choice2": "Dead Tuple 정리",
      "choice3": "인덱스 해체",
      "choice4": "샤딩 자동화",
      "answer": 2,
      "explanation": "Autovacuum은 MVCC로 인해 쌓이는 Dead Tuple을 제거해 성능을 유지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 248,
    "fields": {
      "question": "비정규화(denormalization)를 수행해야 하는 대표적 상황은?",
      "choice1": "트랜잭션이 필요 없는 경우",
      "choice2": "쓰기 성능을 최소화할 때",
      "choice3": "데이터를 반드시 중복 없이 구성해야 할 때",
      "choice4": "조회 성능을 높이기 위해 정규화된 테이블이 너무 많이 조인될 때",
      "answer": 4,
      "explanation": "비정규화는 조인 비용이 너무 클 때 조회 성능을 위해 사용된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 249,
    "fields": {
      "question": "인덱스에서 Cardinality가 낮을 때 비효율적인 이유는?",
      "choice1": "결과 범위가 넓어 인덱스 사용 이점이 줄기 때문이다",
      "choice2": "트랜잭션이 rollback된다",
      "choice3": "정렬이 불가능해지기 때문이다",
      "choice4": "쿼리 옵티마이저가 오류를 발생시킨다",
      "answer": 1,
      "explanation": "Cardinality가 낮으면 많은 데이터를 반환하므로 인덱스의 효율이 크게 감소한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 250,
    "fields": {
      "question": "DBMS에서 Hash Index가 B-Tree보다 불리한 경우는?",
      "choice1": "조인 연산이 적은 경우",
      "choice2": "인덱스 크기를 줄여야 하는 경우",
      "choice3": "등가 검색만 필요한 경우",
      "choice4": "범위 검색이 필요한 경우",
      "answer": 4,
      "explanation": "Hash Index는 범위 검색이 불가하므로 범위 조건이 필요한 경우 적합하지 않다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 251,
    "fields": {
      "question": "분산 환경에서 CAP 이론에서 ‘일관성(Consistency)’의 의미는?",
      "choice1": "쓰기와 읽기가 항상 직렬화됨",
      "choice2": "장애 없이 항상 응답 가능",
      "choice3": "네트워크가 분리되지 않음",
      "choice4": "모든 노드가 같은 시점에 동일한 데이터를 보여줌",
      "answer": 4,
      "explanation": "Consistency는 분산된 시스템의 모든 노드가 동일한 데이터를 보장하는 특성이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 252,
    "fields": {
      "question": "Oracle이나 PostgreSQL에서 사용되는 Latch의 목적은?",
      "choice1": "락 대신 트랜잭션을 종결",
      "choice2": "시스템 콜을 대체",
      "choice3": "메모리 구조 보호",
      "choice4": "SQL 실행 계획 최적화",
      "answer": 3,
      "explanation": "Latch는 공유 메모리 구조의 일관성을 지키기 위한 경량 락이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 253,
    "fields": {
      "question": "Query Optimizer가 힌트(Hint)를 무시할 수 있는 이유는?",
      "choice1": "실행 비용이 더 높은 계획을 발견했기 때문",
      "choice2": "트랜잭션이 이미 커밋되어서",
      "choice3": "인덱스가 제거되어서",
      "choice4": "힌트가 문법적으로 틀려서",
      "answer": 1,
      "explanation": "옵티마이저는 힌트보다 비용이 낮은 계획이 있다고 판단하면 힌트를 무시할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 254,
    "fields": {
      "question": "로그 기반 복구(Log-based Recovery)에서 REDO 작업의 조건은?",
      "choice1": "커밋된 트랜잭션의 변경 사항을 적용한다",
      "choice2": "페이지를 항상 재기록",
      "choice3": "모든 로그를 삭제",
      "choice4": "언커밋된 변경 사항을 취소",
      "answer": 1,
      "explanation": "REDO는 커밋된 데이터를 복구하는 과정이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 255,
    "fields": {
      "question": "Oracle의 Undo Segment의 주된 용도는?",
      "choice1": "DDL 명령 실행",
      "choice2": "캐시 비우기",
      "choice3": "읽기 일관성 제공",
      "choice4": "테이블 구조 변경",
      "answer": 3,
      "explanation": "Undo는 읽기 일관성과 트랜잭션 롤백을 위해 사용된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 256,
    "fields": {
      "question": "Bitmap Index가 유리한 경우는?",
      "choice1": "모든 값이 서로 다른 컬럼에서",
      "choice2": "Low Cardinality 컬럼에서",
      "choice3": "문자열 검색에서",
      "choice4": "정수형 PK 컬럼에서",
      "answer": 2,
      "explanation": "Bitmap Index는 중복이 많고 값 종류가 적은 Low Cardinality 컬럼에 유리하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 257,
    "fields": {
      "question": "DBMS 버퍼 풀(Buffer Pool)에서 Double Write Buffer가 필요한 이유는?",
      "choice1": "쿼리 캐싱을 증가시키기 위해",
      "choice2": "Partial Page Write를 방지하기 위해",
      "choice3": "Redo 로그를 제거하기 위해",
      "choice4": "TLB Miss를 줄이기 위해",
      "answer": 2,
      "explanation": "Double Write는 페이지 일부만 기록되는 문제를 방지하기 위한 구조이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 258,
    "fields": {
      "question": "분산 트랜잭션 환경에서 Clock Skew 문제가 특히 중요한 이유는?",
      "choice1": "쿼리 캐시가 초기화되기 때문",
      "choice2": "DDL이 병렬 수행되기 때문",
      "choice3": "타임스탬프 기반 정렬이 잘못될 수 있기 때문",
      "choice4": "삭제 연산이 증가하기 때문",
      "answer": 3,
      "explanation": "시계 불일치는 타임스탬프 기반 직렬화를 크게 왜곡해 충돌을 초래할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 259,
    "fields": {
      "question": "인덱스 리빌드(Rebuild)가 필요한 상황은?",
      "choice1": "인덱스 조각화가 심할 때",
      "choice2": "정규화를 수행할 때",
      "choice3": "트랜잭션이 짧을 때",
      "choice4": "데이터가 증가하지 않을 때",
      "answer": 1,
      "explanation": "조각난 인덱스는 탐색 성능이 저하되어 rebuild가 필요하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 260,
    "fields": {
      "question": "LSM-Tree(Log-Structured Merge Tree)의 핵심 장점은?",
      "choice1": "쓰기 성능이 매우 높다",
      "choice2": "읽기 성능만 향상된다",
      "choice3": "페이지 교체가 필요 없다",
      "choice4": "모든 데이터를 메모리에 저장",
      "answer": 1,
      "explanation": "LSM Tree는 로그 구조 기반이라 디스크 쓰기를 순차화하여 매우 빠르다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 261,
    "fields": {
      "question": "분산 DB에서 Shard Key 설계가 잘못되면 발생하는 문제는?",
      "choice1": "Hot Spot 현상이 발생한다",
      "choice2": "조회 속도가 항상 빨라진다",
      "choice3": "트랜잭션이 분리되지 않는다",
      "choice4": "ACID가 자동 보장",
      "answer": 1,
      "explanation": "편향된 shard key는 특정 노드에 부하가 집중되어 Hot Spot을 유발한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 262,
    "fields": {
      "question": "Query 실행 시 Hash Join이 Merge Join보다 유리한 경우는?",
      "choice1": "메모리 사용이 제한됨",
      "choice2": "양쪽 모두 인덱스 사용 가능",
      "choice3": "정렬이 되어 있지 않은 대용량 테이블",
      "choice4": "두 테이블 모두 정렬됨",
      "answer": 3,
      "explanation": "Hash Join은 정렬되지 않은 테이블에 효과적이며 대용량 처리에 강하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 263,
    "fields": {
      "question": "ACID 모델의 Durability를 보장하기 위한 핵심 메커니즘은?",
      "choice1": "데이터 캐싱",
      "choice2": "로그 기록과 커밋 시 디스크 반영",
      "choice3": "락 분리",
      "choice4": "쿼리 최적화",
      "answer": 2,
      "explanation": "영속성은 장애 후에도 커밋된 데이터가 유지 되어야 하므로 로그 기반 디스크 기록이 중요하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 264,
    "fields": {
      "question": "Serializable 격리 수준이 가장 느린 이유는?",
      "choice1": "트랜잭션 수를 줄이기 때문",
      "choice2": "완전 직렬화를 보장하기 위해 락 또는 MVCC 스냅샷을 강하게 사용",
      "choice3": "인덱스를 제거하기 때문",
      "choice4": "항상 테이블을 복제",
      "answer": 2,
      "explanation": "Serializable은 가장 높은 격리를 위해 강력한 동시성 제어를 사용하여 성능이 저하된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 265,
    "fields": {
      "question": "PostgreSQL에서 HOT(Heap-Only Tuple) 업데이트 기법의 장점은?",
      "choice1": "VACUUM이 필요 없음",
      "choice2": "항상 빠른 삭제 제공",
      "choice3": "CRUD 속도 균등",
      "choice4": "인덱스를 수정하지 않고 업데이트 가능",
      "answer": 4,
      "explanation": "HOT 업데이트는 인덱스를 갱신하지 않아 오버헤드를 줄일 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 266,
    "fields": {
      "question": "Query Optimizer의 Cardinality Estimation이 잘못되면 생기는 문제는?",
      "choice1": "비효율적 실행 계획 선택",
      "choice2": "트랜잭션 격리 불가",
      "choice3": "정규화 오류",
      "choice4": "데이터 삭제",
      "answer": 1,
      "explanation": "Cardinality 예측이 틀리면 옵티마이저가 잘못된 실행 계획을 선택한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 267,
    "fields": {
      "question": "Distinct 연산이 비용이 큰 이유는?",
      "choice1": "인덱스를 제거하기 때문",
      "choice2": "항상 전체 테이블을 잠그기 때문",
      "choice3": "트랜잭션 충돌 때문",
      "choice4": "정렬 또는 해시 연산이 필요하기 때문",
      "answer": 4,
      "explanation": "DISTINCT는 중복 제거를 위해 정렬/해시가 필요하여 비용이 크다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 268,
    "fields": {
      "question": "Oracle RAC와 같은 공유 디스크 아키텍처의 주요 문제는?",
      "choice1": "트랜잭션 미지원",
      "choice2": "데이터 무결성 유지 불가",
      "choice3": "Global Cache Fusion으로 인한 높은 동기화 비용",
      "choice4": "디스크가 항상 중복 저장됨",
      "answer": 3,
      "explanation": "RAC는 노드 간 캐시를 동기화해야 하므로 비용이 크다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 269,
    "fields": {
      "question": "분산 DB에서 Eventual Consistency가 유효한 시나리오는?",
      "choice1": "일시적 불일치를 허용해도 되는 시스템",
      "choice2": "트랜잭션 전부가 즉시 반영되어야 하는 경우",
      "choice3": "데이터가 절대 바뀌어선 안 되는 경우",
      "choice4": "금융 거래 시스템",
      "answer": 1,
      "explanation": "SNS, 로그 시스템처럼 일시적 불일치가 허용되는 환경에 적합하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 270,
    "fields": {
      "question": "인덱스에서 Covering Index가 쿼리 성능에 유리한 이유는?",
      "choice1": "트랜잭션 격리 수준을 올려주기 때문",
      "choice2": "조회 결과를 자동 압축하기 때문",
      "choice3": "항상 정렬되어 있기 때문",
      "choice4": "테이블에 접근하지 않고 인덱스만으로 결과를 반환할 수 있기 때문",
      "answer": 4,
      "explanation": "Covering Index는 필요한 컬럼이 모두 인덱스에 포함되어 테이블 접근이 불필요하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 3,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 271,
    "fields": {
      "question": "스택(Stack)의 대표적인 특징은?",
      "choice1": "LIFO 구조",
      "choice2": "FIFO 구조",
      "choice3": "정렬된 구조",
      "choice4": "양방향 탐색 구조",
      "answer": 1,
      "explanation": "스택은 마지막에 들어온 데이터가 먼저 나가는 LIFO 구조를 가진다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 272,
    "fields": {
      "question": "큐(Queue)의 기본 동작 방식은?",
      "choice1": "FIFO",
      "choice2": "LIFO",
      "choice3": "해시 기반",
      "choice4": "정렬 기반",
      "answer": 1,
      "explanation": "큐는 먼저 들어온 데이터가 먼저 나오는 FIFO 구조이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 273,
    "fields": {
      "question": "연결 리스트(Linked List)의 장점은?",
      "choice1": "임의 접근이 빠르다",
      "choice2": "항상 작은 메모리를 사용한다",
      "choice3": "정렬이 자동으로 이루어진다",
      "choice4": "중간 삽입/삭제가 빠르다",
      "answer": 4,
      "explanation": "연결 리스트는 노드 연결 방식으로 중간 삽입·삭제가 효율적이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 274,
    "fields": {
      "question": "배열(Array)의 가장 큰 장점은?",
      "choice1": "삽입/삭제가 빠르다",
      "choice2": "항상 정렬된다",
      "choice3": "메모리를 자동 확장한다",
      "choice4": "임의 접근이 빠르다",
      "answer": 4,
      "explanation": "배열은 인덱스를 통해 O(1) 시간에 원소에 접근할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 275,
    "fields": {
      "question": "해시 테이블(Hash Table)의 평균 시간 복잡도는?",
      "choice1": "O(n log n)",
      "choice2": "O(n²)",
      "choice3": "O(log n)",
      "choice4": "O(1)",
      "answer": 4,
      "explanation": "충돌이 적을 경우 해시 테이블의 삽입·탐색은 평균 O(1)이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 276,
    "fields": {
      "question": "트리(Tree)의 최상위 노드를 무엇이라 하는가?",
      "choice1": "리프 노드",
      "choice2": "자식 노드",
      "choice3": "루트 노드",
      "choice4": "부모 노드",
      "answer": 3,
      "explanation": "트리 구조에서 최상단에 위치한 노드를 루트 노드라 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 277,
    "fields": {
      "question": "이진 트리(Binary Tree)에서 자식 노드의 최대 개수는?",
      "choice1": "2개",
      "choice2": "1개",
      "choice3": "3개",
      "choice4": "무제한",
      "answer": 1,
      "explanation": "이진 트리는 각 노드가 최대 2개의 자식을 가진다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 278,
    "fields": {
      "question": "그래프(Graph)에서 정점과 정점을 연결하는 요소는?",
      "choice1": "간선(Edge)",
      "choice2": "버퍼",
      "choice3": "링크",
      "choice4": "노드",
      "answer": 1,
      "explanation": "그래프는 정점(vertex)과 간선(edge)으로 구성된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 279,
    "fields": {
      "question": "BFS 탐색의 기본 자료구조는?",
      "choice1": "트리",
      "choice2": "힙",
      "choice3": "큐",
      "choice4": "스택",
      "answer": 3,
      "explanation": "BFS는 넓이 우선 탐색으로 큐 자료구조를 사용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 280,
    "fields": {
      "question": "DFS 탐색 시 일반적으로 사용하는 자료구조는?",
      "choice1": "트라이",
      "choice2": "스택",
      "choice3": "큐",
      "choice4": "해시 맵",
      "answer": 2,
      "explanation": "DFS는 깊이 우선 탐색으로 스택 또는 재귀 호출을 사용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 281,
    "fields": {
      "question": "최대 힙(Max Heap)에서 루트 노드가 가지는 값의 특징은?",
      "choice1": "가장 큰 값",
      "choice2": "중간 값",
      "choice3": "가장 작은 값",
      "choice4": "정렬된 값",
      "answer": 1,
      "explanation": "최대 힙은 부모 노드가 항상 자식보다 크므로 루트가 최댓값이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 282,
    "fields": {
      "question": "이진 탐색(Binary Search)을 수행하기 위한 배열의 조건은?",
      "choice1": "모두 자연수",
      "choice2": "포인터 기반",
      "choice3": "중복 없는 데이터",
      "choice4": "정렬된 상태",
      "answer": 4,
      "explanation": "이진 탐색은 정렬된 배열에서만 사용할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 283,
    "fields": {
      "question": "원형 큐(Circular Queue)의 목적은?",
      "choice1": "배열의 공간 활용도를 높이기 위해",
      "choice2": "포인터 제거",
      "choice3": "트리 높이 감소",
      "choice4": "정렬 속도 향상",
      "answer": 1,
      "explanation": "원형 큐는 front/rear가 연결되어 배열 낭비를 줄인다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 284,
    "fields": {
      "question": "해시 충돌을 해결하는 방법이 아닌 것은?",
      "choice1": "체이닝",
      "choice2": "이중 해싱",
      "choice3": "정렬 트리 사용",
      "choice4": "오픈 주소법",
      "answer": 3,
      "explanation": "정렬 트리를 사용하는 방식은 일반적인 충돌 해결 방법이 아니다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 285,
    "fields": {
      "question": "스택의 대표적인 활용 사례는?",
      "choice1": "캐싱",
      "choice2": "네트워크 라우팅",
      "choice3": "정렬 알고리즘 최적화",
      "choice4": "함수 호출(콜 스택)",
      "answer": 4,
      "explanation": "함수 호출 구조는 LIFO 방식이므로 스택으로 구현된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 286,
    "fields": {
      "question": "큐의 대표적인 활용 사례는?",
      "choice1": "정렬",
      "choice2": "프로세스 스케줄링",
      "choice3": "그래프 백트래킹",
      "choice4": "함수 호출",
      "answer": 2,
      "explanation": "운영체제의 스케줄링 큐는 FIFO기반으로 동작한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 287,
    "fields": {
      "question": "그래프에서 사이클이 없는 구조는?",
      "choice1": "트리",
      "choice2": "완전 그래프",
      "choice3": "연결 그래프",
      "choice4": "가중 그래프",
      "answer": 1,
      "explanation": "트리는 사이클이 존재하지 않는 그래프이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 288,
    "fields": {
      "question": "연결 리스트의 단점은?",
      "choice1": "정렬이 자동으로 된다",
      "choice2": "배열보다 더 많은 연산이 필요하다",
      "choice3": "삽입 삭제가 느리다",
      "choice4": "임의 접근이 느리다",
      "answer": 4,
      "explanation": "Linked List는 위치 접근이 O(n)으로 느리다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 289,
    "fields": {
      "question": "완전 이진 트리의 특징은?",
      "choice1": "루트가 비어 있다",
      "choice2": "항상 정렬되어 있다",
      "choice3": "왼쪽부터 빈틈없이 채워진다",
      "choice4": "깊이가 모두 같다",
      "answer": 3,
      "explanation": "완전 이진 트리는 위에서 아래, 왼쪽에서 오른쪽으로 빈칸 없이 채워진다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 290,
    "fields": {
      "question": "트라이(Trie)의 주요 용도는?",
      "choice1": "문자열 검색",
      "choice2": "난수 생성",
      "choice3": "정렬",
      "choice4": "해시 계산",
      "answer": 1,
      "explanation": "트라이는 문자열 패턴 검색에 매우 효율적인 트리 구조이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 291,
    "fields": {
      "question": "우선순위 큐(Priority Queue)를 일반적으로 구현하는 자료구조는?",
      "choice1": "스택",
      "choice2": "배열",
      "choice3": "힙",
      "choice4": "링크드 리스트",
      "answer": 3,
      "explanation": "우선순위 큐는 힙을 사용해 높은 우선순위 데이터를 빠르게 꺼낼 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 292,
    "fields": {
      "question": "그래프를 표현하는 방법 중 하나인 인접 행렬(Adjacency Matrix)의 단점은?",
      "choice1": "간선을 저장할 수 없다",
      "choice2": "탐색이 불가능하다",
      "choice3": "메모리 사용량이 많다",
      "choice4": "그래프가 정렬되어야 한다",
      "answer": 3,
      "explanation": "인접 행렬은 정점 개수가 커지면 n² 공간을 사용해 비효율적이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 293,
    "fields": {
      "question": "깊이 우선 탐색(DFS)의 기본 동작 원리는?",
      "choice1": "가장 가까운 정점 먼저 방문",
      "choice2": "랜덤 순서 방문",
      "choice3": "가장 넓게 탐색",
      "choice4": "한 방향으로 깊게 들어가며 탐색",
      "answer": 4,
      "explanation": "DFS는 깊이 중심으로 탐색하며 스택을 활용한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 294,
    "fields": {
      "question": "이진 탐색 트리(BST)의 중위 순회(Inorder Traversal) 결과는?",
      "choice1": "무작위",
      "choice2": "오름차순 정렬된 값",
      "choice3": "내림차순",
      "choice4": "트리 높이",
      "answer": 2,
      "explanation": "BST의 중위 순회는 값이 오름차순으로 출력된다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 295,
    "fields": {
      "question": "Hash Table의 성능을 유지하기 위해 필요한 요소는?",
      "choice1": "데이터 크기 증가",
      "choice2": "적절한 해시 함수",
      "choice3": "충돌 방지 불필요",
      "choice4": "정렬된 테이블",
      "answer": 2,
      "explanation": "좋은 해시 함수는 충돌을 줄여 해시 테이블의 성능을 크게 좌우한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 296,
    "fields": {
      "question": "트리의 말단 노드를 무엇이라 하는가?",
      "choice1": "루트 노드",
      "choice2": "부모 노드",
      "choice3": "리프 노드",
      "choice4": "중간 노드",
      "answer": 3,
      "explanation": "자식이 없는 노드를 리프 노드라 한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 297,
    "fields": {
      "question": "그래프 탐색 시 방문 여부를 저장하는 이유는?",
      "choice1": "무한 루프를 방지하기 위해",
      "choice2": "정렬 결과를 확인하기 위해",
      "choice3": "속도를 줄이기 위해",
      "choice4": "메모리를 줄이기 위해",
      "answer": 1,
      "explanation": "방문 체크가 없으면 사이클 그래프에서 무한 반복이 발생할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 298,
    "fields": {
      "question": "최소 힙(Min Heap)의 루트 노드는 어떤 값을 가지는가?",
      "choice1": "가장 작은 값",
      "choice2": "중간 값",
      "choice3": "가장 큰 값",
      "choice4": "무작위 값",
      "answer": 1,
      "explanation": "최소 힙의 루트는 최솟값이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 299,
    "fields": {
      "question": "큐에서 요소를 제거하는 연산은?",
      "choice1": "push",
      "choice2": "dequeue",
      "choice3": "pop",
      "choice4": "enqueue",
      "answer": 2,
      "explanation": "dequeue는 큐의 front에서 요소를 제거하는 연산이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 300,
    "fields": {
      "question": "스택에서 요소를 추가하는 연산은?",
      "choice1": "append",
      "choice2": "pop",
      "choice3": "push",
      "choice4": "insert",
      "answer": 3,
      "explanation": "push는 스택의 top에 요소를 넣는 연산이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 301,
    "fields": {
      "question": "이진 탐색 트리(BST)가 최악의 경우 성능이 O(n)이 되는 상황은?",
      "choice1": "노드가 모두 동일 값일 때",
      "choice2": "트리가 편향되었을 때",
      "choice3": "탐색 값을 찾지 못했을 때",
      "choice4": "트리 높이가 항상 일정할 때",
      "answer": 2,
      "explanation": "정렬된 데이터를 삽입하면 한쪽으로 치우친 편향트리가 되어 선형 시간이 된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 302,
    "fields": {
      "question": "AVL 트리의 핵심 목적은?",
      "choice1": "메모리 사용 감소",
      "choice2": "정렬 자동 수행",
      "choice3": "최소 높이 보장",
      "choice4": "트리 균형 유지",
      "answer": 4,
      "explanation": "AVL 트리는 삽입/삭제 후 높이 균형을 유지해 탐색 성능을 보장한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 303,
    "fields": {
      "question": "Red-Black Tree의 가장 중요한 성질은?",
      "choice1": "노드 수가 항상 짝수이다",
      "choice2": "최악의 경우에도 O(log n) 높이를 보장한다",
      "choice3": "루트는 반드시 검정이다",
      "choice4": "자식 노드는 항상 두 개이다",
      "answer": 2,
      "explanation": "색 규칙을 통해 트리 높이를 제한하여 로그 시간 탐색을 보장한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 304,
    "fields": {
      "question": "해시 테이블에서 오픈 주소법(Open Addressing)의 단점은?",
      "choice1": "삭제 연산 불가능",
      "choice2": "항상 외부 체인을 사용한다",
      "choice3": "해시 충돌이 발생하지 않는다",
      "choice4": "로드 팩터가 커지면 성능이 급격히 저하된다",
      "answer": 4,
      "explanation": "오픈 주소법은 로드 팩터 증가 시 충돌이 누적되어 성능이 떨어진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 305,
    "fields": {
      "question": "체이닝(Chaining) 방식 해시 테이블에서 길어진 체인의 문제를 줄이기 위한 방법은?",
      "choice1": "더 나은 해시 함수 사용",
      "choice2": "체인을 없애기",
      "choice3": "정렬 트리 사용 금지",
      "choice4": "스택으로 교체",
      "answer": 1,
      "explanation": "해시 함수를 개선하면 분산이 고르게 되어 체인이 짧아진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 306,
    "fields": {
      "question": "최소 신장 트리를 찾는 알고리즘 중 탐욕적(Greedy) 성질을 갖는 것은?",
      "choice1": "Floyd-Warshall",
      "choice2": "Bellman-Ford",
      "choice3": "DFS",
      "choice4": "Kruskal 알고리즘",
      "answer": 4,
      "explanation": "Kruskal은 간선을 정렬해 사이클 없이 최소 비용을 선택하는 탐욕적 알고리즘이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 307,
    "fields": {
      "question": "그래프를 인접 리스트로 표현할 때 장점은?",
      "choice1": "정점 추가가 불가능",
      "choice2": "희소 그래프에서 메모리 효율이 높다",
      "choice3": "항상 빠른 탐색 속도를 제공",
      "choice4": "인접 행렬보다 저장 방식이 단순",
      "answer": 2,
      "explanation": "인접 리스트는 간선이 적은 희소 그래프에서 공간 효율성이 높다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 308,
    "fields": {
      "question": "트라이(Trie)의 시간 복잡도가 문자열 길이에 비례하는 이유는?",
      "choice1": "정렬 과정을 반드시 수행",
      "choice2": "모든 문자열 길이가 동일",
      "choice3": "탐색이 문자 단위로 진행되기 때문",
      "choice4": "해시 충돌이 일어남",
      "answer": 3,
      "explanation": "Trie는 길이가 k인 문자열을 O(k) 시간에 탐색한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 309,
    "fields": {
      "question": "우선순위 큐에서 decrease-key 연산에 가장 효율적인 자료구조는?",
      "choice1": "피보나치 힙(Fibonacci Heap)",
      "choice2": "스택",
      "choice3": "이진 탐색 트리",
      "choice4": "배열",
      "answer": 1,
      "explanation": "피보나치 힙은 decrease-key의 시간복잡도가 매우 낮아 알고리즘에서 자주 사용된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 310,
    "fields": {
      "question": "그래프 탐색에서 백트래킹이 필요한 이유는?",
      "choice1": "정답을 무조건 찾기 위해",
      "choice2": "정렬을 위해",
      "choice3": "탐색 경로가 막힐 때 이전 단계로 되돌아가기 위해",
      "choice4": "모든 그래프가 순환하기 때문에",
      "answer": 3,
      "explanation": "DFS 구조에서 더 갈 곳이 없으면 상위 단계로 되돌아가기 위해 백트래킹한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 311,
    "fields": {
      "question": "힙 정렬(Heap Sort)의 시간 복잡도는?",
      "choice1": "O(log n)",
      "choice2": "O(n)",
      "choice3": "O(n log n)",
      "choice4": "O(n²)",
      "answer": 3,
      "explanation": "힙 구성 + 반복적인 힙 재정렬로 전체 시간 복잡도는 O(n log n)이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 312,
    "fields": {
      "question": "그래프에서 위상 정렬(Topological Sort)이 가능한 조건은?",
      "choice1": "완전 그래프",
      "choice2": "무향 그래프",
      "choice3": "가중치 그래프",
      "choice4": "사이클이 없는 유향 그래프(DAG)",
      "answer": 4,
      "explanation": "위상 정렬은 사이클이 있는 그래프에서는 수행할 수 없다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 313,
    "fields": {
      "question": "LRU 캐시 구현에서 주로 사용되는 자료구조 조합은?",
      "choice1": "배열 + 스택",
      "choice2": "트리 + 큐",
      "choice3": "해시맵 + 이중 연결 리스트",
      "choice4": "해시맵 + 배열",
      "answer": 3,
      "explanation": "해시맵으로 위치를 빠르게 찾고, 이중 연결 리스트로 순서를 관리한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 314,
    "fields": {
      "question": "Union-Find 자료구조에서 \"경로 압축(Path Compression)\"의 목적은?",
      "choice1": "사이클 생성",
      "choice2": "트리 깊이를 줄여 탐색 속도 향상",
      "choice3": "노드를 자동 정렬하기 위해",
      "choice4": "중복 노드 제거",
      "answer": 2,
      "explanation": "경로 압축은 빠른 find 연산을 위해 트리 깊이를 최소화한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 315,
    "fields": {
      "question": "분할 정복(Divide & Conquer) 전략을 사용하는 알고리즘은?",
      "choice1": "DFS",
      "choice2": "Merge Sort",
      "choice3": "계수 정렬",
      "choice4": "힙 정렬",
      "answer": 2,
      "explanation": "Merge Sort는 데이터를 분할하고 정복하는 구조를 따른다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 316,
    "fields": {
      "question": "해시 충돌 해결 방식 중 ‘이중 해싱(Double Hashing)’이 사용하는 방법은?",
      "choice1": "노드 병합",
      "choice2": "보조 해시 함수를 사용해 이동 간격을 결정",
      "choice3": "체인 연결로 충돌 분리",
      "choice4": "메모리 재할당",
      "answer": 2,
      "explanation": "이중 해싱은 두 번째 해시 값으로 충돌 시 이동 간격을 정한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 317,
    "fields": {
      "question": "이진 탐색 트리(BST)에서 삭제 연산 시 처리하기 가장 복잡한 경우는?",
      "choice1": "자식이 없는 경우",
      "choice2": "오른쪽 자식만 있는 경우",
      "choice3": "왼쪽 자식만 있는 경우",
      "choice4": "두 자식을 모두 가진 노드 삭제",
      "answer": 4,
      "explanation": "두 자식이 모두 있는 경우 후계자 선택 과정 때문에 삭제가 복잡하다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 318,
    "fields": {
      "question": "Bloom Filter의 특징은?",
      "choice1": "정확한 검색 결과를 제공한다",
      "choice2": "거짓 양성(False Positive)이 발생할 수 있다",
      "choice3": "삭제가 항상 가능하다",
      "choice4": "항상 해시 충돌을 해결한다",
      "answer": 2,
      "explanation": "Bloom Filter는 공간 효율적이지만 false positive를 허용하는 자료구조이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 319,
    "fields": {
      "question": "Sparse Table이 효율적인 쿼리는?",
      "choice1": "정렬",
      "choice2": "동적 삽입",
      "choice3": "정적 배열에서의 Range Minimum Query(RMQ)",
      "choice4": "그래프 순환 탐색",
      "answer": 3,
      "explanation": "Sparse Table은 업데이트 없는 정적 RMQ 문제에서 강력한 성능을 가진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 320,
    "fields": {
      "question": "Interval Tree의 주 목적은?",
      "choice1": "메모리 분배",
      "choice2": "정렬",
      "choice3": "해시 계산",
      "choice4": "구간 겹침 여부 탐색",
      "answer": 4,
      "explanation": "Interval Tree는 구간 간의 겹침 여부를 빠르게 판단할 때 사용된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 321,
    "fields": {
      "question": "분리 집합(Union-Find) 구조에서 union-by-rank의 목적은?",
      "choice1": "트리의 높이를 줄여 효율적 union 수행",
      "choice2": "랜덤하게 부모 결정",
      "choice3": "모든 트리를 동일 높이로 유지",
      "choice4": "중복 요소 제거",
      "answer": 1,
      "explanation": "랭크 기반 병합은 큰 트리에 작은 트리를 붙여 깊이를 최소화한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 322,
    "fields": {
      "question": "Deque이 Queue와 Stack보다 유리한 점은?",
      "choice1": "메모리가 고정",
      "choice2": "해시 기능이 있다",
      "choice3": "양쪽 끝에서 삽입/삭제가 가능",
      "choice4": "정렬이 빠르다",
      "answer": 3,
      "explanation": "Deque은 양 끝에서 삽입·삭제가 가능한 유연한 자료구조이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 323,
    "fields": {
      "question": "Hash Table의 평균 성능이 유지되기 위해 중요한 요소는?",
      "choice1": "루트 노드 구성",
      "choice2": "로드 팩터 관리",
      "choice3": "정렬 상태",
      "choice4": "그래프 연결성",
      "answer": 2,
      "explanation": "적절한 로드 팩터 유지가 충돌을 줄여 성능을 유지하는 핵심이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 324,
    "fields": {
      "question": "Binary Indexed Tree(Fenwick Tree)의 주요 장점은?",
      "choice1": "정렬된 상태 보장",
      "choice2": "모든 연산이 O(1)",
      "choice3": "범위 최소값 계산",
      "choice4": "구간 합 계산을 O(log n)에 수행",
      "answer": 4,
      "explanation": "BIT는 부분합 문제를 처리하는 효율적인 자료구조이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 325,
    "fields": {
      "question": "그래프의 사이클을 판별하는 대표적 알고리즘은?",
      "choice1": "Union-Find",
      "choice2": "A*",
      "choice3": "Heap",
      "choice4": "DP",
      "answer": 1,
      "explanation": "분리 집합 알고리즘은 사이클 여부를 효율적으로 확인할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 326,
    "fields": {
      "question": "Sorted Array와 Balanced BST를 비교했을 때 BST의 장점은?",
      "choice1": "정렬이 자동으로 된다",
      "choice2": "메모리 사용량이 적다",
      "choice3": "삽입/삭제가 빠르다",
      "choice4": "탐색이 항상 더 빠르다",
      "answer": 3,
      "explanation": "BST는 삽입·삭제가 O(log n)으로 효율적이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 327,
    "fields": {
      "question": "그래프에서 브리지(Bridge)의 정의는?",
      "choice1": "사이클을 구성하는 간선",
      "choice2": "두 노드를 직접 연결하는 간선",
      "choice3": "가중치가 가장 작은 간선",
      "choice4": "제거하면 연결 요소가 증가하는 간선",
      "answer": 4,
      "explanation": "브리지는 제거 시 그래프가 분리되는 중요한 간선이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 328,
    "fields": {
      "question": "셀프 밸런싱 트리에서 LL 회전은 어떤 상황에서 발생하는가?",
      "choice1": "오른쪽 자식의 오른쪽 편향",
      "choice2": "트리 높이가 동일할 때",
      "choice3": "왼쪽 자식의 왼쪽으로 편향될 때",
      "choice4": "부모가 리프 노드일 때",
      "answer": 3,
      "explanation": "LL 불균형은 왼쪽-왼쪽 방향으로 치우친 경우 발생한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 329,
    "fields": {
      "question": "트라이(Trie)가 해시 테이블보다 유리한 상황은?",
      "choice1": "정렬된 숫자 탐색",
      "choice2": "단순 값 저장",
      "choice3": "공통 접두어가 많은 문자열 검색",
      "choice4": "랜덤 접근",
      "answer": 3,
      "explanation": "트라이는 공통 접두어를 공유하므로 문자열 검색에 매우 효율적이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 330,
    "fields": {
      "question": "그래프에서 Eulerian Path가 존재하기 위한 조건은?",
      "choice1": "모든 정점이 동일 차수",
      "choice2": "정점이 짝수 개",
      "choice3": "홀수 차수 정점이 0개 또는 2개",
      "choice4": "사이클이 존재해야 함",
      "answer": 3,
      "explanation": "Eulerian Path는 홀수 차수 정점이 0개이면 회로, 2개이면 경로가 존재한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 331,
    "fields": {
      "question": "스플레이 트리(Splay Tree)의 핵심 장점은?",
      "choice1": "항상 균형 상태를 유지한다",
      "choice2": "삭제가 O(1)에 가깝다",
      "choice3": "최근 접근된 노드를 루트로 이동해 지역성을 높인다",
      "choice4": "정렬이 자동 수행된다",
      "answer": 3,
      "explanation": "스플레이 트리는 최근 사용된 노드를 루트로 옮겨 실제 사용 패턴에서 성능을 높인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 332,
    "fields": {
      "question": "B-Tree와 비교했을 때 B+Tree의 가장 큰 구조적 차이는?",
      "choice1": "모든 키가 중복될 수 있다",
      "choice2": "리프 노드만 실제 데이터를 저장한다",
      "choice3": "모든 노드가 동일 높이다",
      "choice4": "내부 노드가 값을 2개 이상 가진다",
      "answer": 2,
      "explanation": "B+Tree는 리프 노드에만 데이터를 저장하고 내부 노드는 검색용 키만 가진다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 333,
    "fields": {
      "question": "스킵 리스트(Skip List)의 평균 탐색 성능은?",
      "choice1": "O(1)",
      "choice2": "O(log n)",
      "choice3": "O(n)",
      "choice4": "O(n log n)",
      "answer": 2,
      "explanation": "스킵 리스트는 랜덤 레벨 구조로 평균 로그 시간 탐색이 가능하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 334,
    "fields": {
      "question": "피보나치 힙(Fibonacci Heap)이 다익스트라 알고리즘에서 유리한 이유는?",
      "choice1": "모든 연산이 상수 시간",
      "choice2": "decrease-key 연산이 매우 효율적이기 때문",
      "choice3": "모든 노드가 동일 수준을 유지",
      "choice4": "정렬이 자동 적용",
      "answer": 2,
      "explanation": "피보나치 힙은 decrease-key가 아몰티즈드 O(1)로 빠르다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 335,
    "fields": {
      "question": "LRU Cache를 구현할 때 해시맵 + 이중 연결 리스트를 사용하는 근거는?",
      "choice1": "정렬이 자동 수행되어서",
      "choice2": "메모리 사용이 최소화되어서",
      "choice3": "참조 갱신과 제거를 O(1)에 처리할 수 있어서",
      "choice4": "해시 충돌이 없어서",
      "answer": 3,
      "explanation": "해시맵으로 O(1) 조회, 연결 리스트로 O(1) 재배치를 수행할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 336,
    "fields": {
      "question": "트라이(Trie)의 공간 복잡도가 커지는 주요 원인은?",
      "choice1": "노드 branching factor가 크기 때문이다",
      "choice2": "문자열 길이가 짧기 때문",
      "choice3": "트리 높이가 낮기 때문",
      "choice4": "해시 충돌 때문",
      "answer": 1,
      "explanation": "문자 종류가 많을 경우 각 노드가 큰 자식 배열을 가져 메모리 사용이 증가한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 337,
    "fields": {
      "question": "완전 이진 트리 기반 세그먼트 트리에서 업데이트 연산의 시간 복잡도는?",
      "choice1": "O(n log n)",
      "choice2": "O(n)",
      "choice3": "O(1)",
      "choice4": "O(log n)",
      "answer": 4,
      "explanation": "세그먼트 트리는 높이가 log n이므로 업데이트도 O(log n)이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 338,
    "fields": {
      "question": "로프(Rope) 자료구조의 장점은?",
      "choice1": "정렬된 문자열만 저장 가능",
      "choice2": "해시 기반 저장",
      "choice3": "항상 상수 시간 탐색",
      "choice4": "매우 긴 문자열에서 삽입/삭제가 효율적",
      "answer": 4,
      "explanation": "Rope는 문자열을 트리 구조로 나누어 큰 문자열 편집을 효율적으로 한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 339,
    "fields": {
      "question": "Persistent 자료구조의 가장 큰 특징은?",
      "choice1": "정렬된 상태 유지",
      "choice2": "가비지 컬렉션 불필요",
      "choice3": "항상 가장 빠른 탐색 제공",
      "choice4": "이전 버전의 데이터를 보존한다",
      "answer": 4,
      "explanation": "Persistent 구조는 변경 시 기존 데이터의 버전을 유지한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 340,
    "fields": {
      "question": "Z-Order, Hilbert Curve와 같은 공간 채움 곡선(Space-Filling Curve)이 사용되는 이유는?",
      "choice1": "트리 균형 유지",
      "choice2": "그래프 최단경로 계산",
      "choice3": "공간 지역성을 유지하기 위해",
      "choice4": "문자열 비교",
      "answer": 3,
      "explanation": "공간 데이터 인덱싱에서 가까운 점들을 인접 값으로 매핑하여 지역성을 높인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 341,
    "fields": {
      "question": "Suffix Array가 Suffix Tree보다 유리한 점은?",
      "choice1": "메모리 사용량이 적다",
      "choice2": "구성이 더 간단하다",
      "choice3": "항상 더 빠르다",
      "choice4": "문자열 길이에 영향을 받지 않는다",
      "answer": 1,
      "explanation": "동일 기능 대비 Suffix Tree보다 훨씬 적은 메모리를 사용한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 342,
    "fields": {
      "question": "Suffix Tree 구축 알고리즘인 Ukkonen 알고리즘의 시간 복잡도는?",
      "choice1": "O(n)",
      "choice2": "O(n log n)",
      "choice3": "O(log n)",
      "choice4": "O(n²)",
      "answer": 1,
      "explanation": "Ukkonen 알고리즘은 선형 시간에 Suffix Tree를 구축할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 343,
    "fields": {
      "question": "KD-Tree에서 차원 수가 증가할 때 성능이 떨어지는 현상은?",
      "choice1": "스택 오버플로우",
      "choice2": "메모리 누수",
      "choice3": "해시 충돌",
      "choice4": "차원의 저주(Curse of Dimensionality)",
      "answer": 4,
      "explanation": "고차원에서는 분할이 비효율적이 되어 탐색 성능이 급격히 나빠진다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 344,
    "fields": {
      "question": "Bloom Filter가 False Negative를 허용하지 않는 이유는?",
      "choice1": "해시 함수 수가 고정이기 때문",
      "choice2": "계산량이 적기 때문",
      "choice3": "존재하는 값을 없다고 판단하면 데이터 무결성을 깨기 때문",
      "choice4": "비트 배열이 정렬되기 때문",
      "answer": 3,
      "explanation": "False Negative는 신뢰성 문제를 초래하므로 Bloom Filter는 이를 허용하지 않는다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 345,
    "fields": {
      "question": "Red-Black Tree에서 삽입 시 발생하는 경우 중 가장 복잡한 경우는?",
      "choice1": "리프 노드 삽입",
      "choice2": "색 변경 불필요한 경우",
      "choice3": "루트 삽입",
      "choice4": "삼촌 노드가 빨간색일 때",
      "answer": 4,
      "explanation": "삼촌이 빨간색이면 색 재배치와 조상이 연속 수정되어 복잡해진다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 346,
    "fields": {
      "question": "Fenwick Tree(BIT)이 세그먼트 트리보다 유리한 경우는?",
      "choice1": "최대값ㆍ최솟값이 필요할 때",
      "choice2": "구간 업데이트가 복잡할 때",
      "choice3": "구간 연산이 단순 누적합일 때",
      "choice4": "여러 연산을 동시에 처리해야 할 때",
      "answer": 3,
      "explanation": "BIT는 부분합 쿼리에 최적화되어 있으며 구현도 더 간단하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 347,
    "fields": {
      "question": "Hopscotch Hashing의 특징은?",
      "choice1": "근접 버킷을 유지해 캐시 효율을 높인다",
      "choice2": "충돌 발생 시 재해싱 필요",
      "choice3": "정렬된 해시 인덱스 사용",
      "choice4": "항상 체이닝을 사용",
      "answer": 1,
      "explanation": "Hopscotch Hashing은 원래 위치 근방에 데이터를 유지하여 성능을 높인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 348,
    "fields": {
      "question": "Treap(트립)의 핵심 개념은?",
      "choice1": "트리 높이가 항상 일정",
      "choice2": "랜덤 탐색",
      "choice3": "가중치 기반 정렬",
      "choice4": "BST + Heap 특성을 동시에 만족",
      "answer": 4,
      "explanation": "Treap은 키는 BST 규칙, 우선순위는 힙 규칙을 따른다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 349,
    "fields": {
      "question": "Cartesian Tree가 사용되는 대표적인 알고리즘은?",
      "choice1": "BFS",
      "choice2": "RMQ(Range Minimum Query)",
      "choice3": "힙 정렬",
      "choice4": "정렬",
      "answer": 2,
      "explanation": "RMQ 문제를 선형 시간에 해결하기 위한 구조로 Cartesian Tree가 사용된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 350,
    "fields": {
      "question": "Ternary Search Tree(TST)의 장점은?",
      "choice1": "정렬 자동 수행",
      "choice2": "해시보다 충돌이 적다",
      "choice3": "트라이보다 메모리 사용량이 적다",
      "choice4": "검색이 항상 더 빠르다",
      "answer": 3,
      "explanation": "TST는 Trie보다 메모리를 덜 사용하면서 유사한 문자열 검색 기능을 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 351,
    "fields": {
      "question": "Weighted Union(Forest)의 효과는?",
      "choice1": "병합 비용 증가",
      "choice2": "탐색 시간이 O(n)이 됨",
      "choice3": "트리 높이를 줄여 find 연산을 빠르게 한다",
      "choice4": "해시 크기 감소",
      "answer": 3,
      "explanation": "Union-Find에서 무게 기반 병합은 구조를 효율적으로 만든다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 352,
    "fields": {
      "question": "스킵 리스트(Skip List)의 최악 시간 복잡도는?",
      "choice1": "O(log n)",
      "choice2": "O(n)",
      "choice3": "O(n log n)",
      "choice4": "O(1)",
      "answer": 2,
      "explanation": "스킵 리스트는 랜덤 구조라 최악의 경우 선형 시간이 될 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 353,
    "fields": {
      "question": "Splay Tree가 균형 트리보다 불리한 경우는?",
      "choice1": "모든 노드 접근이 동일 빈도로 이루어질 때",
      "choice2": "데이터가 정렬되어 있을 때",
      "choice3": "트리가 매우 작을 때",
      "choice4": "일부 노드만 자주 접근될 때",
      "answer": 1,
      "explanation": "접근 패턴 차이가 없으면 스플레이 동작의 이점이 사라진다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 354,
    "fields": {
      "question": "Skip List에서 레벨 승격(Level Promotion)에 사용하는 기법은?",
      "choice1": "정렬된 순위",
      "choice2": "우선순위 큐",
      "choice3": "동전 던지기 기반 랜덤화",
      "choice4": "해시 기반 결정",
      "answer": 3,
      "explanation": "Skip List는 난수 기반으로 노드의 높이를 결정한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 355,
    "fields": {
      "question": "Segment Tree에서 Lazy Propagation이 필요한 이유는?",
      "choice1": "구간 업데이트 시 전체 트리를 갱신하지 않기 위해",
      "choice2": "정렬된 형태 유지",
      "choice3": "메모리를 줄이기 위해",
      "choice4": "탐색을 빠르게 하기 위해",
      "answer": 1,
      "explanation": "Lazy Propagation은 구간 업데이트를 지연시켜 불필요한 계산을 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 356,
    "fields": {
      "question": "Van Emde Boas Tree(vEB Tree)의 시간 복잡도는?",
      "choice1": "O(log log M)",
      "choice2": "O(n log n)",
      "choice3": "O(log n)",
      "choice4": "O(1)",
      "answer": 1,
      "explanation": "vEB Tree는 매우 빠른 로그 로그 기반의 탐색 성능을 제공한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 357,
    "fields": {
      "question": "링크드 리스트 기반 LRU 구현 시 치명적인 성능 문제는?",
      "choice1": "정렬 불가",
      "choice2": "노드 탐색이 O(n)이다",
      "choice3": "메모리 자동 증가",
      "choice4": "충돌 발생",
      "answer": 2,
      "explanation": "해시맵 없이 리스트만 사용하면 탐색이 느려진다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 358,
    "fields": {
      "question": "Bloom Filter에서 비트 배열 크기를 결정하는 핵심 요소는?",
      "choice1": "문자 인코딩 방식",
      "choice2": "트리 높이",
      "choice3": "허용 가능한 오차 확률",
      "choice4": "배열 정렬 방식",
      "answer": 3,
      "explanation": "비트 배열 크기는 false positive 확률에 따라 결정된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 359,
    "fields": {
      "question": "Rope 자료구조에서 불균형이 발생하면 어떻게 해결하는가?",
      "choice1": "Rebalancing 수행",
      "choice2": "해시 재계산",
      "choice3": "이를 무시",
      "choice4": "전체 문자열 재생성",
      "answer": 1,
      "explanation": "Rope는 트리 기반 구조이므로 균형이 깨지면 재균형이 필요하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 360,
    "fields": {
      "question": "Suffix Automaton(SAM)의 가장 큰 장점은?",
      "choice1": "정렬 속도 향상",
      "choice2": "모든 부분 문자열을 효율적으로 표현",
      "choice3": "트리보다 메모리 적게 사용",
      "choice4": "항상 정렬된 문자열 반환",
      "answer": 2,
      "explanation": "SAM은 문자열의 모든 부분 문자열을 선형 크기로 표현할 수 있는 강력한 자료구조이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 4,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 361,
    "fields": {
      "question": "시간 복잡도(Time Complexity)의 의미는?",
      "choice1": "메모리 용량",
      "choice2": "프로세서의 속도",
      "choice3": "알고리즘 실행 시간이 입력 크기에 따라 증가하는 정도",
      "choice4": "알고리즘의 정확도",
      "answer": 3,
      "explanation": "시간 복잡도는 입력 크기(n)에 따른 알고리즘의 실행 소요 증가량을 나타낸다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 362,
    "fields": {
      "question": "Big-O 표기법에서 O(1)이 의미하는 것은?",
      "choice1": "입력 크기에 비례",
      "choice2": "정렬된 데이터에만 적용",
      "choice3": "항상 가장 빠름",
      "choice4": "입력 크기와 관계없이 일정한 시간",
      "answer": 4,
      "explanation": "O(1)은 입력 크기에 영향을 받지 않는 일정한 시간 복잡도이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 363,
    "fields": {
      "question": "선형 탐색(Linear Search)의 평균 시간 복잡도는?",
      "choice1": "O(1)",
      "choice2": "O(log n)",
      "choice3": "O(n)",
      "choice4": "O(n log n)",
      "answer": 3,
      "explanation": "선형 탐색은 배열을 처음부터 끝까지 확인하므로 평균 O(n)이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 364,
    "fields": {
      "question": "이진 탐색(Binary Search)이 가능하려면 배열은 어떻게 되어 있어야 하는가?",
      "choice1": "음수가 없어야 한다",
      "choice2": "해시 구조여야 한다",
      "choice3": "중복이 없어야 한다",
      "choice4": "정렬되어 있어야 한다",
      "answer": 4,
      "explanation": "이진 탐색은 정렬된 데이터에서만 효율적으로 사용할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 365,
    "fields": {
      "question": "버블 정렬(Bubble Sort)의 기본 동작은?",
      "choice1": "트리를 구성해 정렬",
      "choice2": "가장 작은 값을 선택",
      "choice3": "인접한 두 요소를 비교해 교환",
      "choice4": "병합을 통해 정렬",
      "answer": 3,
      "explanation": "버블 정렬은 인접한 원소를 비교해 큰 값을 뒤로 보낸다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 366,
    "fields": {
      "question": "선택 정렬(Selection Sort)의 특징은?",
      "choice1": "가장 작은 값을 선택해 앞으로 보낸다",
      "choice2": "항상 빠르다",
      "choice3": "재귀 호출이 필요하다",
      "choice4": "병합 기반 정렬이다",
      "answer": 1,
      "explanation": "선택 정렬은 최소값을 선택하여 앞쪽에 배치한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 367,
    "fields": {
      "question": "삽입 정렬(Insertion Sort)의 장점은?",
      "choice1": "항상 O(n log n)",
      "choice2": "메모리 사용이 크다",
      "choice3": "병합이 필요 없다",
      "choice4": "거의 정렬된 데이터에서 매우 빠르다",
      "answer": 4,
      "explanation": "삽입 정렬은 nearly-sorted 데이터에서 최고의 성능을 보인다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 368,
    "fields": {
      "question": "재귀(Recursion)의 특징은?",
      "choice1": "항상 반복문을 대체한다",
      "choice2": "메모리를 절약한다",
      "choice3": "함수가 자기 자신을 호출한다",
      "choice4": "정렬 알고리즘에만 사용된다",
      "answer": 3,
      "explanation": "재귀는 함수가 자기 자신을 호출하여 문제를 해결하는 방식이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 369,
    "fields": {
      "question": "DFS(Depth First Search)의 기본 탐색 방식은?",
      "choice1": "정렬된 순서 탐색",
      "choice2": "무작위 탐색",
      "choice3": "넓게 탐색",
      "choice4": "깊게 탐색",
      "answer": 4,
      "explanation": "DFS는 한 방향으로 깊게 탐색해 나가는 방식이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 370,
    "fields": {
      "question": "BFS(Breadth First Search)의 기본 자료구조는?",
      "choice1": "트리(Tree)",
      "choice2": "힙(Heap)",
      "choice3": "큐(Queue)",
      "choice4": "스택(Stack)",
      "answer": 3,
      "explanation": "BFS는 큐를 사용하여 가까운 노드부터 탐색한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 371,
    "fields": {
      "question": "그리디 알고리즘(Greedy Algorithm)의 핵심 개념은?",
      "choice1": "모든 경우를 탐색한다",
      "choice2": "백트래킹이 필수이다",
      "choice3": "매 순간 최선의 선택을 한다",
      "choice4": "무작위 선택을 한다",
      "answer": 3,
      "explanation": "그리디는 순간 최적 선택을 누적하여 전체 최적해를 구하는 방식이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 372,
    "fields": {
      "question": "다이나믹 프로그래밍(DP)의 두 가지 핵심 조건은?",
      "choice1": "재귀 호출 필수",
      "choice2": "정렬 필요, 탐색 필요",
      "choice3": "DFS 필수, 메모리 큼",
      "choice4": "중복 부분 문제, 최적 부분 구조",
      "answer": 4,
      "explanation": "DP는 문제를 작은 부분 문제로 나눌 수 있고 중복이 있어야 가능하다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 373,
    "fields": {
      "question": "피보나치 수열을 재귀로 구현했을 때 비효율적인 이유는?",
      "choice1": "중복 계산이 많기 때문이다",
      "choice2": "반복문이 없어서",
      "choice3": "할당이 불가능",
      "choice4": "정렬이 필요해서",
      "answer": 1,
      "explanation": "F(n)을 계산하기 위해 동일한 부분 문제를 여러 번 계산해 비효율적이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 374,
    "fields": {
      "question": "탐욕 알고리즘이 항상 최적해를 보장하지 않는 이유는?",
      "choice1": "DFS 기반이기 때문",
      "choice2": "지역 최적해가 전체 최적해와 다를 수 있기 때문",
      "choice3": "자료구조가 필요 없기 때문",
      "choice4": "연산량이 많기 때문",
      "answer": 2,
      "explanation": "순간 최선 선택이 전체 최선이 아닐 수 있어 탐욕 알고리즘은 항상 보장되지 않는다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 375,
    "fields": {
      "question": "병합 정렬(Merge Sort)의 시간 복잡도는?",
      "choice1": "O(log n)",
      "choice2": "O(n)",
      "choice3": "O(n²)",
      "choice4": "O(n log n)",
      "answer": 4,
      "explanation": "Merge Sort는 분할 정복 방식으로 정렬하며 항상 O(n log n)을 가진다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 376,
    "fields": {
      "question": "퀵 정렬(Quick Sort)의 평균 시간 복잡도는?",
      "choice1": "O(n)",
      "choice2": "O(n log n)",
      "choice3": "O(log n)",
      "choice4": "O(n²)",
      "answer": 2,
      "explanation": "평균적으로 피벗 분할이 균등하면 n log n 성능을 낸다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 377,
    "fields": {
      "question": "정렬 알고리즘 중 안정 정렬(Stable Sort)의 의미는?",
      "choice1": "재귀 사용 금지",
      "choice2": "항상 빠르다",
      "choice3": "메모리 사용이 없다",
      "choice4": "동일 값의 순서가 유지된다",
      "answer": 4,
      "explanation": "안정 정렬은 같은 값을 가진 요소의 상대 순서를 보장한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 378,
    "fields": {
      "question": "그래프에서 간선에 가중치가 없는 경우 최단거리 알고리즘은?",
      "choice1": "Floyd-Warshall",
      "choice2": "Bellman-Ford",
      "choice3": "Dijkstra",
      "choice4": "BFS",
      "answer": 4,
      "explanation": "가중치가 동일하면 BFS가 최단 경로를 찾는다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 379,
    "fields": {
      "question": "백트래킹(Backtracking)의 특징은?",
      "choice1": "정렬 기반 탐색",
      "choice2": "해가 아닌 경우 되돌아가서 다른 경로 탐색",
      "choice3": "모든 경우를 무작위로 선택",
      "choice4": "그리디와 동일",
      "answer": 2,
      "explanation": "백트래킹은 조건을 만족하지 않으면 가지를 잘라내며 탐색한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 380,
    "fields": {
      "question": "완전 탐색(Brute Force)의 단점은?",
      "choice1": "정확하지 않다",
      "choice2": "메모리를 많이 사용한다",
      "choice3": "정렬이 필요하다",
      "choice4": "경우의 수가 많으면 시간이 매우 오래 걸린다",
      "answer": 4,
      "explanation": "완전 탐색은 모든 경우를 확인해 매우 느릴 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 381,
    "fields": {
      "question": "최단 거리 알고리즘에서 다익스트라(Dijkstra)가 사용할 수 없는 경우는?",
      "choice1": "양수 가중치만 있을 때",
      "choice2": "음수 가중치가 존재할 때",
      "choice3": "무방향 그래프일 때",
      "choice4": "방향 그래프일 때",
      "answer": 2,
      "explanation": "음수 가중치가 있는 경우 다익스트라는 올바른 최단경로를 찾지 못한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 382,
    "fields": {
      "question": "그리디 알고리즘의 대표적인 문제는?",
      "choice1": "동전 거스름 문제",
      "choice2": "스택 계산",
      "choice3": "정렬 문제",
      "choice4": "이진 탐색",
      "answer": 1,
      "explanation": "동전 단위가 배수 관계일 때 그리디로 최적해를 얻을 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 383,
    "fields": {
      "question": "DP에서 메모이제이션(Memoization)의 개념은?",
      "choice1": "정렬 수행",
      "choice2": "새로운 배열 생성",
      "choice3": "재귀 제거",
      "choice4": "계산한 값을 저장해 재사용",
      "answer": 4,
      "explanation": "메모이제이션은 중복 연산을 줄이기 위해 계산 결과를 저장하는 기법이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 384,
    "fields": {
      "question": "Floyd–Warshall 알고리즘의 용도는?",
      "choice1": "정렬",
      "choice2": "최소 신장 트리",
      "choice3": "모든 정점 간 최단 거리",
      "choice4": "DFS 탐색",
      "answer": 3,
      "explanation": "Floyd–Warshall은 모든 쌍 최단경로(all-pairs shortest path)를 구한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 385,
    "fields": {
      "question": "탐색 알고리즘에서 Heuristic을 사용하는 대표적 알고리즘은?",
      "choice1": "Bellman-Ford",
      "choice2": "DFS",
      "choice3": "BFS",
      "choice4": "A* 알고리즘",
      "answer": 4,
      "explanation": "A*는 휴리스틱을 사용해 탐색 효율을 극대화한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 386,
    "fields": {
      "question": "스택(Stack) 기반으로 해결하는 대표적 문제는?",
      "choice1": "이진 탐색",
      "choice2": "괄호 검사",
      "choice3": "최소 신장 트리",
      "choice4": "정렬",
      "answer": 2,
      "explanation": "괄호 짝 검사 문제는 LIFO 구조의 스택으로 해결할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 387,
    "fields": {
      "question": "두 포인터(Two Pointers) 기법이 효과적인 경우는?",
      "choice1": "힙 기반 탐색",
      "choice2": "랜덤 탐색",
      "choice3": "정렬된 배열에서 구간 탐색",
      "choice4": "비정렬 그래프",
      "answer": 3,
      "explanation": "Two pointers는 정렬된 배열의 범위 탐색에서 매우 효율적이다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 388,
    "fields": {
      "question": "분할 정복(Divide and Conquer) 기법을 사용하는 대표적 알고리즘은?",
      "choice1": "퀵 정렬",
      "choice2": "힙 삽입",
      "choice3": "버블 정렬",
      "choice4": "선형 탐색",
      "answer": 1,
      "explanation": "퀵 정렬은 분할 정복 패턴을 기반으로 동작한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 389,
    "fields": {
      "question": "탐욕적(Greedy) + 정렬을 함께 사용하는 대표 문제는?",
      "choice1": "회의실 배정 문제",
      "choice2": "이진 탐색",
      "choice3": "DFS",
      "choice4": "스택 구현",
      "answer": 1,
      "explanation": "회의 시작 시간/종료 시간을 정렬 후 탐욕 선택하여 해결한다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 390,
    "fields": {
      "question": "Prefix Sum(누적 합)의 시간 복잡도 장점은?",
      "choice1": "구간 합 계산을 O(1)에 수행",
      "choice2": "힙 메모리만 사용",
      "choice3": "모든 연산이 동적",
      "choice4": "정렬이 자동",
      "answer": 1,
      "explanation": "Prefix Sum 배열이 있으면 특정 구간 합을 O(1)로 계산할 수 있다.",
      "created_by_admin": true,
      "difficulty": "easy",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 391,
    "fields": {
      "question": "다익스트라 알고리즘에서 우선순위 큐를 사용하면 얻는 이점은?",
      "choice1": "DFS를 대체한다",
      "choice2": "정점을 가장 적은 비용부터 탐색할 수 있다",
      "choice3": "정렬을 자동 수행한다",
      "choice4": "음수 간선을 처리할 수 있다",
      "answer": 2,
      "explanation": "우선순위 큐를 이용하면 최단 비용 정점을 빠르게 선택할 수 있어 효율적이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 392,
    "fields": {
      "question": "퀵 정렬의 최악 시간 복잡도가 O(n²)이 되는 경우는?",
      "choice1": "정렬이 이미 되어 있을 때",
      "choice2": "병합 정렬과 비교할 때",
      "choice3": "계수 정렬에 비해 느릴 때",
      "choice4": "피벗이 항상 최댓값 또는 최솟값일 때",
      "answer": 4,
      "explanation": "피벗 선택이 계속 한쪽으로 치우치면 분할이 무너져 O(n²) 시간이 된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 393,
    "fields": {
      "question": "DFS를 사용한 사이클 판별이 불가능한 경우는?",
      "choice1": "방향 그래프",
      "choice2": "트리는 아닐 때",
      "choice3": "무방향 그래프",
      "choice4": "가중치 그래프",
      "answer": 4,
      "explanation": "DFS 싸이클 판별은 방향·무방향 그래프에서 가능하나 가중치는 문제와 무관하다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 394,
    "fields": {
      "question": "플로이드–워셜 알고리즘의 시간 복잡도는?",
      "choice1": "O(n)",
      "choice2": "O(n³)",
      "choice3": "O(n²)",
      "choice4": "O(n log n)",
      "answer": 2,
      "explanation": "모든 정점 쌍을 고려하므로 3중 반복문을 사용해 O(n³)이 된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 395,
    "fields": {
      "question": "DP에서 Bottom-Up 방식의 특징은?",
      "choice1": "재귀 기반",
      "choice2": "작은 문제를 먼저 해결해 큰 문제를 해결",
      "choice3": "탐욕 방식이 필요",
      "choice4": "스택 프레임이 많이 필요",
      "answer": 2,
      "explanation": "Bottom-Up은 테이블을 채우며 작은 해부터 큰 해를 계산한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 396,
    "fields": {
      "question": "이분 탐색(Binary Search)에서 mid 계산 시 overflow 방지 방식은?",
      "choice1": "mid = low * high",
      "choice2": "mid = low + (high - low) / 2",
      "choice3": "mid = (low + high) / 2",
      "choice4": "mid = high / 2",
      "answer": 2,
      "explanation": "low + high가 큰 경우 overflow가 발생할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 397,
    "fields": {
      "question": "분할정복(Divide and Conquer)의 대표적인 문제는?",
      "choice1": "최대 부분 배열 합 (Maximum Subarray Problem)",
      "choice2": "이진 탐색 트리 순회",
      "choice3": "계수 정렬",
      "choice4": "BFS",
      "answer": 1,
      "explanation": "최대 부분합 문제는 분할정복으로 해결할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 398,
    "fields": {
      "question": "BFS로 최단 경로를 구할 수 없는 경우는?",
      "choice1": "가중치가 1이 아닌 경우",
      "choice2": "가중치가 1일 때",
      "choice3": "트리",
      "choice4": "무방향 그래프",
      "answer": 1,
      "explanation": "BFS는 모든 간선 가중치가 동일해야 최단경로가 보장된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 399,
    "fields": {
      "question": "KMP 문자열 검색 알고리즘의 장점은?",
      "choice1": "공백 문자를 제거",
      "choice2": "불일치가 발생해도 비교 정보를 활용해 재검사를 줄인다",
      "choice3": "정렬을 자동 수행",
      "choice4": "해시 기반 탐색",
      "answer": 2,
      "explanation": "KMP는 prefix 정보를 활용해 불필요한 비교를 줄인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 400,
    "fields": {
      "question": "투 포인터(Two Pointers)가 비효율적인 경우는?",
      "choice1": "양 끝 탐색 필요",
      "choice2": "정렬되지 않은 배열",
      "choice3": "구간 합 계산",
      "choice4": "정렬된 배열",
      "answer": 2,
      "explanation": "투 포인터는 정렬 기반 문제에서 효과적이며 비정렬 배열에서는 효율이 떨어진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 401,
    "fields": {
      "question": "위상 정렬(Topological Sort)이 불가능한 그래프는?",
      "choice1": "사이클 없는 유향 그래프",
      "choice2": "비가중 그래프",
      "choice3": "사이클이 있는 그래프",
      "choice4": "트리",
      "answer": 3,
      "explanation": "위상 정렬은 DAG(사이클 없는 유향 그래프)에서만 가능하다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 402,
    "fields": {
      "question": "비트마스크 기법의 장점은?",
      "choice1": "정렬이 필요없다",
      "choice2": "집합을 정수로 표현해 연산이 빠르다",
      "choice3": "그래프 탐색 수 감소",
      "choice4": "문자열 처리 최적화",
      "answer": 2,
      "explanation": "비트 연산은 매우 빠르며 집합 표현에 적합하다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 403,
    "fields": {
      "question": "다이나믹 프로그래밍에서 “상향식 테이블 접근” 방식은?",
      "choice1": "Brute Force",
      "choice2": "Greedy",
      "choice3": "Top-Down",
      "choice4": "Bottom-Up",
      "answer": 4,
      "explanation": "Bottom-Up 방식은 테이블을 차례대로 채우는 방식이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 404,
    "fields": {
      "question": "백트래킹이 DFS보다 더 많은 가지치기를 할 수 있는 이유는?",
      "choice1": "스택을 사용하지 않음",
      "choice2": "항상 정답을 보장",
      "choice3": "조건을 검사하여 불필요한 탐색을 미리 제거할 수 있기 때문",
      "choice4": "재귀 깊이가 일정",
      "answer": 3,
      "explanation": "백트래킹은 조건을 만족하지 않는 경로를 제거해 탐색 공간을 줄인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 405,
    "fields": {
      "question": "다익스트라 알고리즘에서 Relaxation(완화)의 정의는?",
      "choice1": "모든 정점을 방문하는 과정",
      "choice2": "정점을 삭제하는 과정",
      "choice3": "더 짧은 경로를 찾으면 거리 값을 갱신하는 과정",
      "choice4": "그래프를 정렬하는 과정",
      "answer": 3,
      "explanation": "Relaxation은 현재 거리보다 짧은 경로가 발견되면 값을 변경하는 작업이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 406,
    "fields": {
      "question": "분할정복 알고리즘이 병렬화에 유리한 이유는?",
      "choice1": "정렬을 포함하기 때문에",
      "choice2": "항상 재귀를 사용해서",
      "choice3": "시간 복잡도가 낮아서",
      "choice4": "하위 문제들이 독립적인 경우가 많아서",
      "answer": 4,
      "explanation": "부분 문제들이 독립적이면 병렬로 처리할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 407,
    "fields": {
      "question": "Hashing을 이용한 문자열 검색 알고리즘은?",
      "choice1": "Suffix Array",
      "choice2": "Rabin-Karp",
      "choice3": "Brute Force",
      "choice4": "KMP",
      "answer": 2,
      "explanation": "Rabin–Karp는 문자열을 해싱하여 비교 속도를 높인다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 408,
    "fields": {
      "question": "DP로 해결할 수 없는 문제의 특징은?",
      "choice1": "부분합 요구",
      "choice2": "중복 부분 문제가 존재하지 않음",
      "choice3": "정렬 필요",
      "choice4": "탐색이 많음",
      "answer": 2,
      "explanation": "중복 부분 문제가 없으면 DP 이점이 사라진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 409,
    "fields": {
      "question": "사이클이 있는 그래프에서 최단 경로를 구할 수 있는 알고리즘은?",
      "choice1": "Dijkstra",
      "choice2": "Prim",
      "choice3": "Bellman-Ford",
      "choice4": "BFS",
      "answer": 3,
      "explanation": "Bellman-Ford는 음수 간선·사이클이 있어도 처리할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 410,
    "fields": {
      "question": "프림(Prim) 알고리즘이 크루스칼(Kruskal)보다 유리한 경우는?",
      "choice1": "간선이 매우 많은 밀집 그래프일 때",
      "choice2": "간선이 거의 없을 때",
      "choice3": "정점이 항상 적을 때",
      "choice4": "순열 필요",
      "answer": 1,
      "explanation": "Prim은 우선순위 큐 기반으로 밀집 그래프에서 효율적이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 411,
    "fields": {
      "question": "방문 배열(visited)을 사용하지 않으면 DFS가 잘못될 수 있는 이유는?",
      "choice1": "정렬이 불가능",
      "choice2": "사이클이 있을 경우 무한 루프 발생",
      "choice3": "메모리 증가",
      "choice4": "탐색이 너무 빠름",
      "answer": 2,
      "explanation": "사이클에서 방문 체크가 없으면 DFS는 동일 경로를 계속 방문해 무한 루프가 된다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 412,
    "fields": {
      "question": "투 포인터(Two Pointers) 대신 슬라이딩 윈도우(Sliding Window)를 사용하는 이유는?",
      "choice1": "연속된 구간을 유지하면서 조건을 만족시키기 위해",
      "choice2": "트리 구조를 포함해서",
      "choice3": "정렬이 필요해서",
      "choice4": "항상 더 빠르기 때문",
      "answer": 1,
      "explanation": "슬라이딩 윈도우는 연속 구간의 조건을 유지해야 할 때 적합하다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 413,
    "fields": {
      "question": "이진 탐색 트리(BST)가 균형을 잃으면 어떤 문제가 생기는가?",
      "choice1": "값의 중복이 발생한다",
      "choice2": "메모리가 증가한다",
      "choice3": "시간 복잡도가 O(n)이 된다",
      "choice4": "항상 정렬이 깨진다",
      "answer": 3,
      "explanation": "편향되면 선형 구조가 되어 탐색 성능이 O(n)으로 떨어진다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 414,
    "fields": {
      "question": "그리디 알고리즘으로 해결할 수 있는 대표적 문제는?",
      "choice1": "Bellman-Ford",
      "choice2": "활동 선택(Activity Selection) 문제",
      "choice3": "LCS 문제",
      "choice4": "DFS",
      "answer": 2,
      "explanation": "활동 선택 문제는 종료 시간을 기준으로 탐욕 선택이 최적해를 만든다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 415,
    "fields": {
      "question": "비트마스크를 이용해 모든 부분집합을 구할 때 시간 복잡도는?",
      "choice1": "O(2ⁿ)",
      "choice2": "O(log n)",
      "choice3": "O(n²)",
      "choice4": "O(n)",
      "answer": 1,
      "explanation": "n개의 비트를 통해 총 2ⁿ개의 부분집합을 생성할 수 있다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 416,
    "fields": {
      "question": "플로이드 알고리즘에서 대각선 요소를 0으로 초기화하는 이유는?",
      "choice1": "그래프가 무방향이어서",
      "choice2": "정렬 필요",
      "choice3": "메모리 절약",
      "choice4": "자기 자신까지의 거리는 0이기 때문",
      "answer": 4,
      "explanation": "i에서 i까지의 최단 경로는 비용이 0이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 417,
    "fields": {
      "question": "위상 정렬에서 큐를 사용하는 이유는?",
      "choice1": "DFS보다 빠르기 때문",
      "choice2": "진입 차수가 0인 정점을 순차적으로 꺼내기 위해",
      "choice3": "정렬이 필요하기 때문",
      "choice4": "트리를 만들기 위해",
      "answer": 2,
      "explanation": "진입 차수가 0인 노드를 큐에 넣어 순서대로 처리한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 418,
    "fields": {
      "question": "탐욕 알고리즘이 사용된 허프만 코딩(Huffman Coding)의 핵심 개념은?",
      "choice1": "트리를 균형 있게 유지",
      "choice2": "항상 정렬된 문자열 처리",
      "choice3": "가장 빈도가 낮은 두 노드를 병합",
      "choice4": "해시 기반 탐색",
      "answer": 3,
      "explanation": "Huffman은 빈도 낮은 노드부터 병합해 최적 압축 트리를 만든다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 419,
    "fields": {
      "question": "이진 탐색을 이용한 Lower Bound의 정의는?",
      "choice1": "배열의 끝 인덱스",
      "choice2": "값이 정확히 일치하는 위치",
      "choice3": "찾고자 하는 값보다 큰 값",
      "choice4": "찾고자 하는 값 이상이 처음 나타나는 위치",
      "answer": 4,
      "explanation": "Lower Bound는 “첫 번째로 값 ≥ target”인 위치이다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 420,
    "fields": {
      "question": "N! 시간 복잡도를 가진 알고리즘의 특징은?",
      "choice1": "완전 탐색(Brute Force) 형태로 입력 크기 증가 시 급격히 폭발한다",
      "choice2": "정렬 문제에만 사용된다",
      "choice3": "항상 빠르다",
      "choice4": "DP를 반드시 포함한다",
      "answer": 1,
      "explanation": "N!은 입력이 조금만 증가해도 계산량이 폭발적으로 증가한다.",
      "created_by_admin": true,
      "difficulty": "medium",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 421,
    "fields": {
      "question": "세그먼트 트리에서 Lazy Propagation이 필요한 이유는?",
      "choice1": "구간 업데이트 시 불필요한 전체 트리 갱신을 방지하기 위해",
      "choice2": "메모리를 줄이기 위해",
      "choice3": "항상 탐색 속도를 높이기 위해",
      "choice4": "리프 노드를 제거하기 위해",
      "answer": 1,
      "explanation": "Lazy Propagation은 구간 업데이트를 지연 저장하여 성능을 최적화한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 422,
    "fields": {
      "question": "KMP 알고리즘에서 실패 함수(π 배열)의 역할은?",
      "choice1": "문자열을 정렬한다",
      "choice2": "문자열을 압축한다",
      "choice3": "불일치 발생 시 점프해야 할 패턴 위치를 알려준다",
      "choice4": "해시 충돌을 해결한다",
      "answer": 3,
      "explanation": "실패 함수는 이전 부분 일치를 활용해 재탐색을 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 423,
    "fields": {
      "question": "최소 신장 트리(MST)에서 크루스칼(Kruskal)이 Prim보다 유리한 경우는?",
      "choice1": "정점이 매우 적을 때",
      "choice2": "가중치가 모두 동일할 때",
      "choice3": "간선이 많은 밀집 그래프일 때",
      "choice4": "간선이 적은 희소 그래프일 때",
      "answer": 4,
      "explanation": "Kruskal은 간선 정렬 기반이므로 sparse 그래프에서 효과적이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 424,
    "fields": {
      "question": "벨만-포드 알고리즘은 다익스트라보다 느리지만 필요한 이유는?",
      "choice1": "메모리가 적게 필요",
      "choice2": "항상 더 정확",
      "choice3": "음수 가중치를 처리할 수 있기 때문이다",
      "choice4": "정렬을 자동 수행하기 때문",
      "answer": 3,
      "explanation": "Bellman-Ford는 음수 간선이 있는 그래프에서도 동작한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 425,
    "fields": {
      "question": "A* 알고리즘에서 휴리스틱(Heuristic)이 만족해야 하는 조건은?",
      "choice1": "정렬되어야 함",
      "choice2": "0이어야 함",
      "choice3": "과대추정해야 함",
      "choice4": "Admissible(과소추정해야 함)",
      "answer": 4,
      "explanation": "휴리스틱은 실제 비용보다 작거나 같아야 최단 경로 보장이 가능하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 426,
    "fields": {
      "question": "Convex Hull 알고리즘 중 Graham Scan의 시간 복잡도는?",
      "choice1": "O(n)",
      "choice2": "O(n log n)",
      "choice3": "O(log n)",
      "choice4": "O(n²)",
      "answer": 2,
      "explanation": "Graham Scan은 정렬 후 스택을 이용해 볼록 껍질을 찾는다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 427,
    "fields": {
      "question": "이진 검색 트리(BST)에서 Order Statistics(순위 조회)를 빠르게 제공하기 위한 방법은?",
      "choice1": "배열로 변환",
      "choice2": "각 노드에 서브트리 크기 저장",
      "choice3": "해시값 저장",
      "choice4": "균형 무시",
      "answer": 2,
      "explanation": "서브트리 크기를 저장하면 k번째 원소 탐색이 O(log n)에 가능하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 428,
    "fields": {
      "question": "Dinic 알고리즘이 Edmonds–Karp보다 빠른 이유는?",
      "choice1": "모든 간선이 동일 가중치이기 때문",
      "choice2": "정렬 기반이기 때문",
      "choice3": "레벨 그래프(Level Graph)를 사용하기 때문",
      "choice4": "힙을 반드시 사용하기 때문",
      "answer": 3,
      "explanation": "Dinic은 레벨 그래프 + blocking flow로 빠른 최대 유량 계산이 가능하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 429,
    "fields": {
      "question": "트라이(Trie)보다 Suffix Automaton(SAM)이 유리한 경우는?",
      "choice1": "문자열 길이가 매우 짧을 때",
      "choice2": "공백 제거가 필요할 때",
      "choice3": "정렬된 문자열만 필요할 때",
      "choice4": "문자열의 모든 부분 문자열을 효율적으로 표현할 때",
      "answer": 4,
      "explanation": "SAM은 모든 부분 문자열을 선형 공간에 저장할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 430,
    "fields": {
      "question": "분할정복 기반 최대 부분합 알고리즘의 시간 복잡도는?",
      "choice1": "O(log n)",
      "choice2": "O(n²)",
      "choice3": "O(n log n)",
      "choice4": "O(n)",
      "answer": 3,
      "explanation": "좌/우/중간 부분합을 계산하는 분할정복 구조로 n log n 성능이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 431,
    "fields": {
      "question": "Z-algorithm의 주요 용도는?",
      "choice1": "가중치 그래프 탐색",
      "choice2": "문자열에서 접두사(prefix) 일치 길이 계산",
      "choice3": "최소 신장 트리",
      "choice4": "정렬",
      "answer": 2,
      "explanation": "Z 배열은 문자열 위치마다 접두사 일치 길이를 알려준다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 432,
    "fields": {
      "question": "DP의 상태 정의에서 중요한 요소는?",
      "choice1": "문자열이어야 한다",
      "choice2": "그래프 기반이어야 한다",
      "choice3": "문제를 부분 문제로 명확히 분해할 수 있어야 한다",
      "choice4": "항상 재귀여야 한다",
      "answer": 3,
      "explanation": "DP는 문제를 작게 분해해 상태 정의가 명확해야 적용 가능하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 433,
    "fields": {
      "question": "Heavy-Light Decomposition(HLD)의 목적은?",
      "choice1": "힙을 생성하기 위해",
      "choice2": "트리를 압축하기 위해",
      "choice3": "트리 경로 쿼리를 빠르게 처리하기 위해",
      "choice4": "정렬을 수행하기 위해",
      "answer": 3,
      "explanation": "HLD는 트리 경로를 분해하여 세그먼트 트리로 빠르게 처리한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 434,
    "fields": {
      "question": "FFT(Fast Fourier Transform)의 시간 복잡도는?",
      "choice1": "O(n²)",
      "choice2": "O(n log n)",
      "choice3": "O(n)",
      "choice4": "O(log n)",
      "answer": 2,
      "explanation": "FFT는 신호 처리 및 큰 수 곱셈 등에 활용되는 분할정복 기반 알고리즘이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 435,
    "fields": {
      "question": "스프래그–그런디 정리(Sprague-Grundy theorem)가 적용되는 문제 유형은?",
      "choice1": "비트마스크 문제",
      "choice2": "두 사람이 번갈아 하는 무작위 없는(Deterministic) 게임",
      "choice3": "정렬 문제",
      "choice4": "최단거리 문제",
      "answer": 2,
      "explanation": "Nim 게임과 같이 임partial 게임에서 승패 분석에 사용된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 436,
    "fields": {
      "question": "Push–Relabel(Max Flow) 알고리즘의 특징은?",
      "choice1": "DFS 기반",
      "choice2": "정점 기준으로 흐름을 조정한다",
      "choice3": "간선을 정렬한다",
      "choice4": "레벨 그래프를 사용한다",
      "answer": 2,
      "explanation": "Push–Relabel은 정점 높이(height)를 기준으로 흐름을 조정한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 437,
    "fields": {
      "question": "2-SAT 문제 해결에 사용되는 알고리즘은?",
      "choice1": "SCC(Strongly Connected Components)",
      "choice2": "Greedy",
      "choice3": "FFT",
      "choice4": "KMP",
      "answer": 1,
      "explanation": "2-SAT은 implication graph 구축 후 SCC로 해답을 구한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 438,
    "fields": {
      "question": "분할정복 + DP를 결합한 Knuth Optimization이 적용되려면 어떤 조건이 필요한가?",
      "choice1": "Quadrangle Inequality",
      "choice2": "음수 가중치 존재",
      "choice3": "트리가 필요",
      "choice4": "정렬 필수",
      "answer": 1,
      "explanation": "Knuth Optimization은 DP 성질 중 사각 부등식이 필요하다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 439,
    "fields": {
      "question": "Convex Hull Trick(CHT)이 유용한 DP 유형은?",
      "choice1": "문자열 기반",
      "choice2": "순열 기반",
      "choice3": "비트마스크 기반",
      "choice4": "점화식이 선형(linear) 형태일 때",
      "answer": 4,
      "explanation": "CHT는 직선 형태의 DP 점화식 최적화에 사용된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 440,
    "fields": {
      "question": "Mo’s Algorithm이 사용되는 대표적 문제 유형은?",
      "choice1": "DP 최적화",
      "choice2": "최단 거리",
      "choice3": "정렬",
      "choice4": "Offline range query",
      "answer": 4,
      "explanation": "Mo’s Algorithm은 여러 구간 쿼리를 sqrt 분할해 효율적으로 처리한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 441,
    "fields": {
      "question": "Suffix Array를 O(n log n) 시간에 구성하기 위해 사용하는 방식은?",
      "choice1": "Radix Sort",
      "choice2": "Doubling 기법",
      "choice3": "Greedy",
      "choice4": "Heap",
      "answer": 2,
      "explanation": "문자열을 두 배씩 확장하며 정렬하는 doubling 방식이 일반적이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 442,
    "fields": {
      "question": "Johnson 알고리즘이 필요한 상황은?",
      "choice1": "음수 간선 + 모든 쌍 최단거리 APSP 필요",
      "choice2": "트리 탐색",
      "choice3": "계수 기반",
      "choice4": "정렬",
      "answer": 1,
      "explanation": "Johnson 알고리즘은 음수 간선이 있어도 모든 정점 간 최단거리를 구할 수 있다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 443,
    "fields": {
      "question": "Meet-in-the-middle 기법의 시간 복잡도는?",
      "choice1": "O(1)",
      "choice2": "O(2^(n/2))",
      "choice3": "O(n!)",
      "choice4": "O(2^n)",
      "answer": 2,
      "explanation": "n을 두 부분으로 나누어 탐색해 2^(n/2)으로 줄인다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 444,
    "fields": {
      "question": "Manacher 알고리즘의 주요 기능은?",
      "choice1": "최단 거리 계산",
      "choice2": "트리를 분해",
      "choice3": "정렬한다",
      "choice4": "모든 홀수/짝수 길이 팰린드롬을 O(n)에 찾는다",
      "answer": 4,
      "explanation": "Manacher는 팰린드롬 탐색을 선형시간에 해결하는 알고리즘이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 445,
    "fields": {
      "question": "Hungarian Algorithm의 용도는?",
      "choice1": "최소 신장 트리",
      "choice2": "이진 탐색",
      "choice3": "정렬 수행",
      "choice4": "이분 매칭에서 최소 비용 매칭을 구한다",
      "answer": 4,
      "explanation": "Hungarian 알고리즘은 최소 비용 완전 매칭을 찾는 알고리즘이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 446,
    "fields": {
      "question": "Tarjan 알고리즘이 사용하는 자료구조는?",
      "choice1": "Queue",
      "choice2": "Union-Find",
      "choice3": "Stack",
      "choice4": "Heap",
      "answer": 3,
      "explanation": "Tarjan의 SCC 알고리즘은 스택 기반으로 low-link 값을 계산한다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 447,
    "fields": {
      "question": "ZKW 알고리즘은 어떤 문제를 해결하기 위한 알고리즘인가?",
      "choice1": "최소 비용 최대 유량(Min Cost Max Flow)",
      "choice2": "정렬 문제",
      "choice3": "트리 경로 분해",
      "choice4": "부분합",
      "answer": 1,
      "explanation": "ZKW는 최소 비용 최대 유량을 빠르게 구하는 알고리즘이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 448,
    "fields": {
      "question": "Li Chao Tree는 어떤 문제를 해결하기 위한 자료구조인가?",
      "choice1": "직선(Line) 기반 DP 최적화",
      "choice2": "정렬",
      "choice3": "그래프 최단 경로",
      "choice4": "KMP",
      "answer": 1,
      "explanation": "Li Chao Tree는 선형 함수 최적값 쿼리를 효율적으로 처리하는 자료구조이다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 449,
    "fields": {
      "question": "Euler Tour Technique(ETT)의 주요 용도는?",
      "choice1": "그리디 최적화",
      "choice2": "문자열 정렬",
      "choice3": "배열 압축",
      "choice4": "트리 구조를 배열로 변환해 구간 쿼리 처리",
      "answer": 4,
      "explanation": "ETT는 트리를 DFS 순서 배열로 변환하여 세그먼트 트리와 함께 사용된다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  },
  {
    "model": "questions.problem",
    "pk": 450,
    "fields": {
      "question": "SMAWK 알고리즘은 어떤 문제를 해결하기 위한 알고리즘인가?",
      "choice1": "최대 유량",
      "choice2": "최단 경로",
      "choice3": "Monge 배열에서 행 최소값 찾기",
      "choice4": "정렬",
      "answer": 3,
      "explanation": "SMAWK는 Monge 성질을 가진 행렬에서 각 행의 최소값을 빠르게 찾는다.",
      "created_by_admin": true,
      "difficulty": "hard",
      "category": 5,
      "created_at": "2025-12-04T07:09:34.243509Z",
      "updated_at": "2025-12-04T07:09:34.243509Z"
    }
  }
]